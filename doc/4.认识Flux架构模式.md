<div class="article-detail">
                    <h2 class="article-tit">
                        第 5 章　深入 Redux 应用架构
                    </h2>
                    <div class="typo typo-selection">
                        <div id="article" class="markdown-body">
                            
<p>从 Flux 身上我们领略到数据在 store、action creator、dispatcher 及 React 组件之间单向流动的美妙特性，但在它受到越来越多关注的同时，我们也发现了 Flux 的一些问题与不足。因此，优化和扩展 Flux 架构的方案不断涌现，其中不乏许多高质量的作品，如 reflux、fluxxor 等。但是很快，一个后起之秀脱颖而出，短短数月就在 GitHub 上收获近万 star，它就是 Redux。</p>
<p>为什么 Redux 在短时间内就受到了如此高的追捧？Redux 和 Flux 相比有什么异同？如何从零开始搭建一个 Redux 应用？这些问题将在本章中一一为你揭晓。</p>
<h2><strong>5.1　Redux 简介</strong></h2>
<p>现在我们就从 Redux 是什么、Redux 的三大原则和 Redux 的核心 API 开始介绍 Redux，并说明 Redux 如何与 React 结合使用，以及它在 Flux 基础上的改变。</p>
<h3><strong>5.1.1　Redux 是什么</strong></h3>
<p>我们都知道 Flux 本身既不是库，也不是框架，而是一种应用的架构思想。而 Redux 呢，它的核心代码可以理解成一个库，但同时也强调与 Flux 类似的架构思想。</p>
<p>从设计上看，Redux 参考了 Flux 的设计，但是对 Flux 许多冗余的部分（如 dispatcher）做了简化，同时将 Elm 语言中函数式编程的思想融合其中。</p>
<p>非常有意思的是，Redux 是从一个实验开始的，作者 Dan Abramov 并没有想到 Redux 会变得如此重要又被广泛使用，他只是为了通过 Flux 思想解决他的热重载及时间旅行的问题而已。</p>
<p>Redux 本身非常简单，它的设计思想与 React 有异曲同工之妙，均是希望用最少的 API 实现最核心的功能。</p>
<p>图 5-1 是 Redux 的核心运作流程，看起来比 Flux 要简单不少。因为 Redux 本身只把自己定位成一个“可预测的状态容器”，所以图 5-1 只能算是这个容器的运行过程。而一个完整的 Redux 应用的运作流程，远比图 5-1 复杂得多。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.001.png" alt="{%}"></p>
<p><strong>图 5-1　Redux 的核心运作流程</strong></p>
<p>“Redux”本身指 redux 这个 npm 包，它提供若干 API 让我们使用 reducer 创建 store，并能够更新 store 中的数据或获取 store 中最新的状态。而“Redux 应用”则是指使用了 redux 这个 npm 包并结合了视图层实现（如 React）及其他前端应用必备组件（路由库、Ajax 请求库）组成的完整的类 Flux 思想的前端应用。</p>
<h3><strong>5.1.2　Redux 三大原则</strong></h3>
<p>想要理解 Redux，必须要知道 Redux 设计和使用的三大原则。</p>
<p><strong>1. 单一数据源</strong></p>
<p>在传统的 MVC 架构中，我们可以根据需要创建无数个 Model，而 Model 之间可以互相监听、触发事件甚至循环或嵌套触发事件，这些在 Redux 中都是不允许的。</p>
<p>因为在 Redux 的思想里，一个应用永远只有唯一的数据源。我们的第一反应可能是：如果有一个复杂应用，强制要求唯一的数据源岂不是会产生一个特别庞大的 JavaScript 对象。</p>
<p>实际上，使用单一数据源的好处在于整个应用状态都保存在一个对象中，这样我们随时可以提取出整个应用的状态进行持久化（比如实现一个针对整个应用的即时保存功能）。此外，这样的设计也为服务端渲染提供了可能。</p>
<p>至于我们担心的数据源对象过于庞大的问题，可以在 5.6.8 节中看到 Redux 提供的工具函数 <code>combineReducers</code> 是如何化解的。</p>
<p><strong>2. 状态是只读的</strong></p>
<p>这一点和 Flux 的思想不谋而合，不同的是在 Flux 中，因为 store 没有 setter 而限制了我们直接修改应用状态的能力，而在 Redux 中，这样的限制被执行得更加彻底，因为我们压根没有 store。</p>
<p>在 Redux 中，我们并不会自己用代码来定义一个 store。取而代之的是，我们定义一个 reducer，它的功能是根据当前触发的 action 对当前应用的状态（state）进行迭代，这里我们并没有直接修改应用的状态，而是返回了一份全新的状态。</p>
<p>Redux 提供的 <code>createStore</code> 方法会根据 reducer 生成 store。最后，我们可以利用 <code>store.dispatch</code> 方法来达到修改状态的目的。</p>
<p><strong>3. 状态修改均由纯函数完成</strong></p>
<p>这是Redux与Flux 在表现上的最大不同。在 Flux 中，我们在<code>actionCreator</code>里调用<code>AppDispatcher.dispatch</code> 方法来触发 action，这样不仅有冗余的代码，而且因为直接修改了 store 中的数据，将导致无法保存每次数据变化前后的状态。</p>
<p>在 Redux 里，我们通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。</p>
<p>这样设计的好处不仅在于 reducer 里对状态的修改变得简单、纯粹、可测试，更有意思的是，Redux 利用每次新返回的状态生成酷炫的时间旅行（time travel）调试方式，让跟踪每一次因为触发 action 而改变状态的结果成为了可能。</p>
<h3><strong>5.1.3　Redux 核心 API</strong></h3>
<p>Redux 的核心是一个 store，这个 store 由 Redux 提供的 <code>createStore(reducers[, initialState])</code> 方法生成。从函数签名看出，要想生成 store，必须要传入 <code>reducers</code>，同时也可以传入第二个可选参数初始化状态（<code>initialState</code>）。</p>
<p>在继续了解 <code>createStore</code> 之前，让我们先认识一下 <code>reducers</code>。在上一章介绍 Flux 时我们说到，Flux 的核心思想之一就是不直接修改数据，而是分发一个 action 来描述发生的改变。那么，在 Redux 里由谁来修改数据呢？</p>
<p>在 Redux 里，负责响应 action 并修改数据的角色就是 reducer。reducer 本质上是一个函数，其函数签名为 <code>reducer(previousState, action) =&gt; newState</code>。可以看出，reducer 在处理 action 的同时，还需要接受一个 <code>previousState</code> 参数。所以，reducer 的职责就是根据 <code>previousState</code> 和 <code>action</code> 计算出新的 <code>newState</code>。</p>
<p>在实际应用中，reducer 在处理 <code>previousState</code> 时，还需要有一个特殊的非空判断。很显然，reducer 第一次执行的时候，并没有任何的 <code>previousState</code>，而 reducer 的最终职责是返回新的 state，因此需要在这种特殊情况下返回一个定义好的 <code>initialState</code>：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="com">// MyReducer.js</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> initialState </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  todos</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[],</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="com">// 我们定义的 todos 这个 reducer 在第一次执行的时候，会返回 { todos: [] } 作为初始化状态</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> todos</span><span class="pun">(</span><span class="pln">previousState </span><span class="pun">=</span><span class="pln"> initialState</span><span class="pun">,</span><span class="pln"> action</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">action</span><span class="pun">.</span><span class="pln">type</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">case</span><span class="pln"> </span><span class="str">'XXX'</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 具体的业务逻辑</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">default</span><span class="pun">:</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> previousState</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>根据 Dan Abramov 的说法，Redux 这个名字就是来源于 Reduce+Flux，可见 reducer 在整个 Redux 架构中拥有举足轻重的作用。</p>
<p>下面就是 Redux 中最核心的 API——<code>createStore</code>：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> createStore </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> store </span><span class="pun">=</span><span class="pln"> createStore</span><span class="pun">(</span><span class="pln">reducers</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>通过 <code>createStore</code> 方法创建的 <code>store</code> 是一个对象，它本身又包含 4 个方法。</p>
<ul>
<li><p><strong><code>getState()</code></strong>：获取 store 中当前的状态。</p>
</li>
<li><p><strong><code>dispatch(action)</code></strong>：分发一个 action，并返回这个 action，这是唯一能改变 store 中数据的方式。</p>
</li>
<li><p><strong><code>subscribe(listener)</code></strong>：注册一个监听者，它在 store 发生变化时被调用。</p>
</li>
<li><p><strong><code>replaceReducer(nextReducer)</code></strong>：更新当前 store 里的 reducer，一般只会在开发模式中调用该方法。</p>
</li>
</ul>
<p>在实际使用中，我们最常用的是 <code>getState()</code> 和 <code>dispatch()</code> 这两个方法。至于 <code>subscribe()</code> 和 <code>replaceReducer()</code>方法，一般会在 Redux 与某个系统（如 React）做桥接的时候使用。</p>
<p>关于这 4 个方法的具体作用和实现，请参考 6.5 节。</p>
<h3><strong>5.1.4　与 React 绑定</strong></h3>
<p>前面说到 Redux 的核心只有一个 <code>createStore()</code> 方法，但是仅仅使用这个方法还不足以让 Redux 在我们的 React 应用中发挥作用。我们还需要 react-redux 库——Redux 官方提供的 React 绑定。</p>
<p>很多刚刚接触 React 和 Redux 的开发者可能会好奇，明明有了 Redux，为什么还需要 react-redux，为什么不把它们放在一起？事实上，这是一种前端框架或类库的架构趋势，即尽可能做到平台无关（platform agnostic）。我们在第1章中也提到过，即便是 React，也在 0.14 版本之后拆分了 React 和 ReactDOM 两个库。这样拆分的好处在于，一个类库从核心逻辑上、具体与平台相关的实现上这两个层面做了拆分，能保证核心功能做到最大程度的跨平台复用。</p>
<p>react-redux 提供了一个组件和一个 API 帮助 Redux 和 React 进行绑定，一个是 React 组件 <code>&lt;Provider/&gt;</code> ，一个是 <code>connect()</code>。关于它们，只需要知道的是， <code>&lt;Provider/&gt;</code> 接受一个 store 作为 props，它是整个 Redux 应用的顶层组件，而 <code>connect()</code> 提供了在整个 React 应用的任意组件中获取 <code>store</code> 中数据的功能。</p>
<p>关于这两个方法，在 6.6 节中会有更详细的介绍。</p>
<h3><strong>5.1.5　增强 Flux 的功能</strong></h3>
<p>我们在上一章中提到，Flux 的一个很大的不足在于定义的模式太过松散，这导致许多采用了 Flux 模式的开发者在实际开发过程中遇到一个很纠结的问题：在哪里发请求，如何处理异步流？</p>
<p>在 Redux 中，这种异步 action 的需求可以通过 Redux 原生的 middleware 设计来实现。在 
5.2 节中，我们将看到更多关于 Redux middleware 的介绍与使用。</p>
<p>正如 Redux 官方代码库的介绍中所说，Redux 是一个可预测的状态容器（predictable state container）。简单地说，在摒弃了传统 MVC 的发布/订阅模式并通过 Redux 三大原则强化对状态的修改后，使用 Redux 可以让你的应用状态管理变得可预测、可追溯。在 5.6 节中，我们会以一个完整的例子来展示 Redux 应用是如何帮助我们优化数据修改过程以及梳理数据流动方式的。</p>
<h2><strong>5.2　Redux middleware</strong></h2>
<p>“It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.”</p>
<p>这是 Dan Abramov 对 middleware 的描述。它提供了一个分类处理 action 的机会。在 middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会。</p>
<h3><strong>5.2.1　middleware 的由来</strong></h3>
<p>图 5-2 表达的是 Redux 中一个简单的同步数据流动场景，点击 button 后，在回调中分发一个 action， reducer 收到 action 后，更新 state 并通知 view 重新渲染。单向数据流，看着没什么问题。但是，如果需要打印每一个 action 信息来调试，就得去改 dispatch 或者 reducer 实现，使其具有打印日志的功能。又比如，点击 button 后，需要先去服务端请求数据，只有等数据返回后，才能重新渲染 view，此时我们希望 dispatch 或 reducer 拥有异步请求的功能。再比如，需要异步请求数据返回后，打印一条日志，再请求数据，再打印日志，再渲染。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.002.png" alt="{%}"></p>
<p><strong>图 5-2　Redux 同步数据流动</strong></p>
<p>面对多样的业务场景，单纯地修改 dispatch 或 reducer 的代码显然不具有普适性，我们需要的是可以组合的、自由插拔的插件机制，这一点 Redux 借鉴了 Koa （它是用于构建 Web 应用的 Node.js 框架）里 middleware 的思想，详情可查阅附录 A。另外，Redux 中 reducer 更关心的是数据的转化逻辑，所以 middleware 就是为了增强 dispatch 而出现的。</p>
<p>图 5-3 展示了应用 middleware 后 Redux 处理事件的逻辑，每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware 实现变化多样的功能。那么，后续我们就来讨论 middleware 是怎么写的，以及 Redux 是如何让 middleware 串联起来的。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.003.png" alt="{%}"></p>
<p><strong>图 5-3　应用 middleware 后 Redux 处理事件的逻辑</strong></p>
<h3><strong>5.2.2　理解 middleware 机制</strong></h3>
<p>Redux 提供了 <code>applyMiddleware</code> 方法来加载 middleware，该方法的源码如下：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> compose </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./compose'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> applyMiddleware</span><span class="pun">(...</span><span class="pln">middlewares</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">next</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">reducer</span><span class="pun">,</span><span class="pln"> initialState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">let</span><span class="pln"> store </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">reducer</span><span class="pun">,</span><span class="pln"> initialState</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">let</span><span class="pln"> dispatch </span><span class="pun">=</span><span class="pln"> store</span><span class="pun">.</span><span class="pln">dispatch</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">let</span><span class="pln"> chain </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[];</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> middlewareAPI </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      getState</span><span class="pun">:</span><span class="pln"> store</span><span class="pun">.</span><span class="pln">getState</span><span class="pun">,</span><span class="pln">
      dispatch</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="pln">action</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> dispatch</span><span class="pun">(</span><span class="pln">action</span><span class="pun">),</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
    chain </span><span class="pun">=</span><span class="pln"> middlewares</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">middleware </span><span class="pun">=&gt;</span><span class="pln"> middleware</span><span class="pun">(</span><span class="pln">middlewareAPI</span><span class="pun">));</span><span class="pln">
    dispatch </span><span class="pun">=</span><span class="pln"> compose</span><span class="pun">(...</span><span class="pln">chain</span><span class="pun">)(</span><span class="pln">store</span><span class="pun">.</span><span class="pln">dispatch</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="pun">...</span><span class="pln">store</span><span class="pun">,</span><span class="pln">
      dispatch</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><code>applyMiddleware</code> 的代码虽然只有二十多行，却非常精炼。</p>
<p>然后再来看 logger middleware 的实现：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> store </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'dispatch:'</span><span class="pun">,</span><span class="pln"> action</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'finish:'</span><span class="pun">,</span><span class="pln"> action</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>接下来，我们就分 4 步来深入解析 middleware 的运行原理。</p>
<blockquote>
<p><strong>说明</strong>　Redux 的代码都是用 ES6/ES7 写的，不熟悉 <code>store =&gt; next =&gt; action =&gt; {}</code> 或 <code>...state</code> 的读者，可以先学习下箭头函数<span class="注释编号">1</span>和展开运算符<span class="注释编号">2</span>。</p>
</blockquote>
<p class="注释内容"><span class="注释编号下">1</span>Arrow functions，详见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>。</p>
<p class="注释内容"><span class="注释编号下">2</span>Spread operator，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator</a>。</p>
<p><strong>1. 函数式编程思想设计</strong></p>
<p>middleware 的设计有点特殊，是一个层层包裹的匿名函数，这其实是函数式编程中的 currying，它是一种使用匿名单参数函数来实现多参数函数的方法。<code>applyMiddleware</code> 会对 logger 这个 middleware 进行层层调用，动态地将 <code>store</code> 和 <code>next</code> 参数赋值。</p>
<p>currying 的 middleware 结构的好处主要有以下两点。</p>
<ul>
<li><p><strong>易串联</strong>：currying 函数具有延迟执行的特性，通过不断 currying 形成的 middleware 可以累积参数，再配合组合（compose）的方式，很容易形成 pipeline 来处理数据流。</p>
</li>
<li><p><strong>共享 store</strong>：在 <code>applyMiddleware</code> 执行的过程中，store 还是旧的，但是因为闭包的存在，<code>applyMiddleware</code> 完成后，所有的 middleware 内部拿到的 store 是最新且相同的。</p>
</li>
</ul>
<p>另外，我们会发现 <code>applyMiddleware</code> 的结构也是一个多层 currying 的函数。借助 compose，<code>applyMiddleware</code> 可以用来和其他插件加强 <code>createStore</code> 函数：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> createStore</span><span class="pun">,</span><span class="pln"> applyMiddleware</span><span class="pun">,</span><span class="pln"> compose </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'Redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> rootReducer </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../reducers'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">DevTools</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../containers/DevTools'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> finalCreateStore </span><span class="pun">=</span><span class="pln"> compose</span><span class="pun">(</span><span class="pln">
  </span><span class="com">// 在开发环境中使用的 middleware</span><span class="pln">
  applyMiddleware</span><span class="pun">(</span><span class="pln">d1</span><span class="pun">,</span><span class="pln"> d2</span><span class="pun">,</span><span class="pln"> d3</span><span class="pun">),</span><span class="pln">
  </span><span class="com">// 它会启动 Redux DevTools</span><span class="pln">
  </span><span class="typ">DevTools</span><span class="pun">.</span><span class="pln">instrument</span><span class="pun">()</span><span class="pln">
</span><span class="pun">)(</span><span class="pln">createStore</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p><strong>2. 给 middleware 分发 store</strong></p>
<p>通过如下方式创建一个普通的 store ：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">let</span><span class="pln"> newStore </span><span class="pun">=</span><span class="pln"> applyMiddleware</span><span class="pun">(</span><span class="pln">mid1</span><span class="pun">,</span><span class="pln"> mid2</span><span class="pun">,</span><span class="pln"> mid3</span><span class="pun">,</span><span class="pln"> </span><span class="pun">...)(</span><span class="pln">createStore</span><span class="pun">)(</span><span class="pln">reducer</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>上述代码执行完后，<code>applyMiddleware</code> 方法陆续获得了3个参数，第一个是 <code>middlewares</code> 数组 <code>[mid<sub>1</sub>, mid<sub>2</sub>, mid<sub>3</sub>, ...]</code>，第二个是 Redux 原生的 <code>createStore</code> ，最后一个是 <code>reducer</code>。然后，我们可以看到 <code>applyMiddleware</code> 利用 <code>createStore</code> 和 <code>reducer</code> 创建了一个 store。而 store 的 <code>getState</code> 方法和 <code>dispatch</code> 方法又分别被直接和间接地赋值给 <code>middlewareAPI</code> 变量 <code>store</code>：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> middlewareAPI </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  getState</span><span class="pun">:</span><span class="pln"> store</span><span class="pun">.</span><span class="pln">getState</span><span class="pun">,</span><span class="pln">
  dispatch</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="pln">action</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> dispatch</span><span class="pun">(</span><span class="pln">action</span><span class="pun">),</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

chain </span><span class="pun">=</span><span class="pln"> middlewares</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">middleware </span><span class="pun">=&gt;</span><span class="pln"> middleware</span><span class="pun">(</span><span class="pln">middlewareAPI</span><span class="pun">));</span><span class="pln">
</span></code></pre>
<p>然后，让每个 middleware 带着 <code>middlewareAPI</code> 这个参数分别执行一遍。执行完后，获得 <code>chain</code> 数组 <code>[f<sub>1</sub>, f<sub>2</sub>, ... , f<sub>x</sub>, ..., f<sub>n</sub>]</code>，它保存的对象是第二个箭头函数返回的匿名函数。因为是闭包，每个匿名函数都可以访问相同的 store，即 <code>middlewareAPI</code>。</p>
<blockquote>
<p><strong>说明</strong></p>
<p><code>middlewareAPI</code> 中的 dispatch 为什么要用匿名函数包裹呢？</p>
<p>我们用 <code>applyMiddleware</code> 是为了改造 dispatch，所以 <code>applyMiddleware</code> 执行完后，dispatch 是变化了的，而 <code>middlewareAPI</code> 是 <code>applyMiddleware</code> 执行中分发到各个 middleware 的，所以必须用匿名函数包裹 dispatch，这样只要 dispatch 更新了，<code>middlewareAPI</code> 中的 dispatch 应用也会发生变化。</p>
</blockquote>
<p><strong>3. 组合串联 middleware</strong></p>
<p>这一层只有一行代码，却是 <code>applyMiddleware</code> 精华之所在：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">dispatch </span><span class="pun">=</span><span class="pln"> compose</span><span class="pun">(...</span><span class="pln">chain</span><span class="pun">)(</span><span class="pln">store</span><span class="pun">.</span><span class="pln">dispatch</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>其中 <code>compose</code> 是函数式编程中的组合，它将 <code>chain</code> 中的所有匿名函数 <code>[f<sub>1</sub>, f<sub>2</sub>, ... , f<sub>x</sub>, ..., f<sub>n</sub>]</code> 组装成一个新的函数，即新的 dispatch。当新 dispatch 执行时，<code>[f<sub>1</sub>, f<sub>2</sub>, ... , f<sub>x</sub>, ..., f<sub>n</sub>]</code>，从右到左依次执行。Redux 中 <code>compose</code> 的实现是下面这样的，当然实现方式并不唯一：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">function</span><span class="pln"> compose</span><span class="pun">(...</span><span class="pln">funcs</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> arg </span><span class="pun">=&gt;</span><span class="pln"> funcs</span><span class="pun">.</span><span class="pln">reduceRight</span><span class="pun">((</span><span class="pln">composed</span><span class="pun">,</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> f</span><span class="pun">(</span><span class="pln">composed</span><span class="pun">),</span><span class="pln"> arg</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><code>compose(...funcs)</code> 返回的是一个匿名函数，其中 <code>funcs</code> 就是 <code>chain</code> 数组。当调用 <code>reduceRight</code> 时，依次从 <code>funcs</code> 数组的右端取一个函数 <code>f<sub>x</sub></code> 拿来执行，<code>f<sub>x</sub></code> 的参数 <code>composed</code> 就是前一次 <code>f<sub>x+1</sub></code> 执行的结果，而第一次执行的 <code>f<sub>n</sub></code>（n 代表 <code>chain</code> 的长度）的参数 <code>arg</code> 就是 <code>store.dispatch</code>。所以，当 <code>compose</code> 执行完后，我们得到的 dispatch 是这样的，假设 <code>n = 3</code>：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">dispatch </span><span class="pun">=</span><span class="pln"> f1</span><span class="pun">(</span><span class="pln">f2</span><span class="pun">(</span><span class="pln">f3</span><span class="pun">(</span><span class="pln">store</span><span class="pun">.</span><span class="pln">dispatch</span><span class="pun">))));</span><span class="pln">
</span></code></pre>
<p>这时调用新 dispatch，每一个 middleware 就依次执行了。</p>
<p><strong>4. 在 middleware 中调用 dispatch 会发生什么</strong></p>
<p>经过 <code>compose</code> 后，所有的 middleware 算是串联起来了。可是还有一个问题，在分发 store 时，我们提到过每个 middleware 都可以访问 store，即 <code>middlewareAPI</code> 这个变量，也可以拿到 store 的 <code>dispatch</code> 属性。那么，在 middleware 中调用 <code>store.dispatch()</code> 会发生什么，和调用 <code>next()</code> 有区别吗？现在我们来说明两者的不同：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> logger </span><span class="pun">=</span><span class="pln"> store </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'dispatch:'</span><span class="pun">,</span><span class="pln"> action</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'finish:'</span><span class="pun">,</span><span class="pln"> action</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> logger </span><span class="pun">=</span><span class="pln"> store </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'dispatch:'</span><span class="pun">,</span><span class="pln"> action</span><span class="pun">);</span><span class="pln">
  store</span><span class="pun">.</span><span class="pln">dispatch</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'finish:'</span><span class="pun">,</span><span class="pln"> action</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>在分发 store 时我们解释过，middleware 中 store 的 dispatch 通过匿名函数的方式和最终 <code>compose</code> 结束后的新 dispatch 保持一致，所以，在 middleware 中调用 <code>store.dispatch()</code> 和在其他任何地方调用的效果一样。而在 middleware 中调用 <code>next()</code>，效果是进入下一个 middleware，如图 5-4 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.004.png" alt="{%}"></p>
<p><strong>图 5-4　Redux middleware 流程图</strong></p>
<p>正常情况下，如图 5-4 左图所示，当我们分发一个 action 时，middleware 通过 <code>next(action)</code> 一层层处理和传递 action 直到 Redux 原生的 dispatch。如果某个 middleware 使用<code>store.dispatch(action)</code> 来分发 action，就发生了如图 5-4 右图所示的情况，这相当于重新来一遍。假如这个 middleware 一直简单粗暴地调用 <code>store.dispatch(action)</code>，就会形成无限循环了。那么 <code>store.dispatch(action)</code> 的用武之地在哪里呢？</p>
<p>假如我们需要发送一个异步请求到服务端获取数据，成功后弹出一个自定义的 message。这里我们用到了 Redux Thunk：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> thunk </span><span class="pun">=</span><span class="pln"> store </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">typeof</span><span class="pln"> action </span><span class="pun">===</span><span class="pln"> </span><span class="str">'function'</span><span class="pln"> </span><span class="pun">?</span><span class="pln">
    action</span><span class="pun">(</span><span class="pln">store</span><span class="pun">.</span><span class="pln">dispatch</span><span class="pun">,</span><span class="pln"> store</span><span class="pun">.</span><span class="pln">getState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln">
    </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">)</span><span class="pln">
</span></code></pre>
<p>Redux Thunk 会判断 <code>action</code> 是否是函数。如果是，则执行 action，否则继续传递 action 到下一个 middleware。针对于此，我们设计了以下 action：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> getThenShow </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dispatch</span><span class="pun">,</span><span class="pln"> getState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> url </span><span class="pun">=</span><span class="pln"> </span><span class="str">'http://xxx.json'</span><span class="pun">;</span><span class="pln">

  fetch</span><span class="pun">(</span><span class="pln">url</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">((</span><span class="pln">response</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      dispatch</span><span class="pun">({</span><span class="pln">
        type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'SHOW_MESSAGE_FOR_ME'</span><span class="pun">,</span><span class="pln">
        message</span><span class="pun">:</span><span class="pln"> response</span><span class="pun">.</span><span class="pln">json</span><span class="pun">(),</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">})</span><span class="pln">
    </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      dispatch</span><span class="pun">({</span><span class="pln">
        type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'FETCH_DATA_FAIL'</span><span class="pun">,</span><span class="pln">
        message</span><span class="pun">:</span><span class="pln"> </span><span class="str">'error'</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>这时候只要在应用中调用 <code>store.dispatch(getThenShow)</code>，Redux Thunk 就会执行 <code>getThenShow</code> 方法。<code>getThenShow</code> 会先请求数据，如果成功，分发一个显示 message 的 action；否则，分发一个请求失败的 action。而这里的 dispatch 就是通过 Redux Thunk middleware 传递进来的。</p>
<p>在 middleware 中使用 dispatch 的场景一般是接受到一个定向 action，这个 action 并不希望到达原生的分发 action，往往用在异步请求的需求里。在下一节中，我们会详细讨论如何在 Redux 中实现异步流。</p>
<h2><strong>5.3　Redux 异步流</strong></h2>
<p>曾经前端的革新是以 Ajax 的出现为分水岭，现代应用中绝大部分页面渲染会以异步流的方式进行。我们还记得在 Flux 中，并没有定义在哪里发异步请求，那么 Redux 是如何解决这个问题的呢？</p>
<h3><strong>5.3.1　使用 middleware 简化异步请求</strong></h3>
<p>在这一节中，我们通过介绍最常用的 3 个 middleware 来介绍 Redux 怎样发异步请求。</p>
<p><strong>1. redux-thunk</strong></p>
<p>我们试想，如果要发异步请求，在 Redux 定义中，最合适的位置是在 action creator 中实现。但我们之前了解到的 action 都是同步情况，那么怎样让 action 支持异步情况呢？</p>
<p>这里引入了 redux-thunk middleware。首先我们需要知道什么是 thunk？其实在学习 Node.js 时，已经接触并熟悉 <code>Thunk</code> 函数了。比如：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">fs</span><span class="pun">.</span><span class="pln">readFile</span><span class="pun">(</span><span class="pln">fileName</span><span class="pun">,</span><span class="pln"> callback</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> readFileThunk </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Thunk</span><span class="pun">(</span><span class="pln">fileName</span><span class="pun">);</span><span class="pln">
readFileThunk</span><span class="pun">(</span><span class="pln">callback</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> </span><span class="typ">Thunk</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">fileName</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">callback</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> fs</span><span class="pun">.</span><span class="pln">readFile</span><span class="pun">(</span><span class="pln">fileName</span><span class="pun">,</span><span class="pln"> callback</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p><code>Thunk</code> 函数实现上就是针对多参数的 currying 以实现对函数的惰性求值。任何函数，只要参数有回调函数，就能写成 <code>Thunk</code> 函数的形式。</p>
<p>我们再来看看 redux-thunk 的源代码：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">function</span><span class="pln"> createThunkMiddleware</span><span class="pun">(</span><span class="pln">extraArgument</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">({</span><span class="pln"> dispatch</span><span class="pun">,</span><span class="pln"> getState </span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">typeof</span><span class="pln"> action </span><span class="pun">===</span><span class="pln"> </span><span class="str">'function'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> action</span><span class="pun">(</span><span class="pln">dispatch</span><span class="pun">,</span><span class="pln"> getState</span><span class="pun">,</span><span class="pln"> extraArgument</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>我们很清楚地看到，当 <code>action</code> 为函数的时候，我们并没有调用 <code>next</code> 或 <code>dispatch</code> 方法，而是返回 <code>action</code> 的调用。这里的 <code>action</code> 即为一个 Thunk 函数，以达到将 <code>dispatch</code> 和 <code>getState</code> 参数传递到函数内的作用。</p>
<p>了解 redux-thunk 的原理后，这里我们模拟请求一个天气的异步请求。action 通常可以这么写：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">function</span><span class="pln"> getWeather</span><span class="pun">(</span><span class="pln">url</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">params</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dispatch</span><span class="pun">,</span><span class="pln"> getState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    fetch</span><span class="pun">(</span><span class="pln">url</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">params</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">result </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        dispatch</span><span class="pun">({</span><span class="pln">
          type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'GET_WEATHER_SUCCESS'</span><span class="pun">,</span><span class="pln">
          payload</span><span class="pun">:</span><span class="pln"> result</span><span class="pun">,</span><span class="pln">
        </span><span class="pun">});</span><span class="pln">
      </span><span class="pun">})</span><span class="pln">
      </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">err </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        dispatch</span><span class="pun">({</span><span class="pln">
          type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'GET_WEATHER_ERROR'</span><span class="pun">,</span><span class="pln">
          error</span><span class="pun">:</span><span class="pln"> err</span><span class="pun">,</span><span class="pln">
        </span><span class="pun">});</span><span class="pln">
     </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>我们顺利地把同步 action 变成了异步 action。</p>
<p>尽管我们利用 <code>Thunk</code> 可以完成各种复杂的异步 action，但是对于某些复杂但是又有规律的场景，抽离出更合适的、目标更明确的 middleware 来解决会是更好的方案，而异步请求绝对是其一。</p>
<p><strong>2. redux-promise</strong></p>
<p>我们发现，异步请求其实都是利用 promise 来完成的，那么为什么不通过抽象 promise 来解决异步流的问题呢？</p>
<p>这里再引入 redux-promise middleware，然后通过源码来分析一下它是怎么做的：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> isFSA </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'flux-standard-action'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> isPromise</span><span class="pun">(</span><span class="pln">val</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> val </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">typeof</span><span class="pln"> val</span><span class="pun">.</span><span class="kwd">then</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> </span><span class="str">'function'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> promiseMiddleware</span><span class="pun">({</span><span class="pln"> dispatch </span><span class="pun">})</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">isFSA</span><span class="pun">(</span><span class="pln">action</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> isPromise</span><span class="pun">(</span><span class="pln">action</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">?</span><span class="pln"> action</span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">dispatch</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> isPromise</span><span class="pun">(</span><span class="pln">action</span><span class="pun">.</span><span class="pln">payload</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">?</span><span class="pln"> action</span><span class="pun">.</span><span class="pln">payload</span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">
          result </span><span class="pun">=&gt;</span><span class="pln"> dispatch</span><span class="pun">({</span><span class="pln"> </span><span class="pun">...</span><span class="pln">action</span><span class="pun">,</span><span class="pln"> payload</span><span class="pun">:</span><span class="pln"> result </span><span class="pun">}),</span><span class="pln">
          error </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            dispatch</span><span class="pun">({</span><span class="pln"> </span><span class="pun">...</span><span class="pln">action</span><span class="pun">,</span><span class="pln"> payload</span><span class="pun">:</span><span class="pln"> error</span><span class="pun">,</span><span class="pln"> error</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">});</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Promise</span><span class="pun">.</span><span class="pln">reject</span><span class="pun">(</span><span class="pln">error</span><span class="pun">);</span><span class="pln">
          </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">)</span><span class="pln">
      </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>redux-promise 兼容了 FSA 标准，也就是说将返回的结果保存在 <code>payload</code> 中。实现过程非常容易理解，即判断 <code>action</code> 或 <code>action.payload</code> 是否为 promise，如果是，就执行 <code>then</code>，返回的结果再发送一次 dispatch。</p>
<p>我们利用 ES7 的 <code>async</code> 和 <code>await</code> 语法，可以简化上述异步过程：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> fetchData </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">url</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">params</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> fetch</span><span class="pun">(</span><span class="pln">url</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">params</span><span class="pun">);</span><span class="pln">

async </span><span class="kwd">function</span><span class="pln"> getWeather</span><span class="pun">(</span><span class="pln">url</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">params</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> await fetchData</span><span class="pun">(</span><span class="pln">url</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">params</span><span class="pun">);</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">result</span><span class="pun">.</span><span class="pln">error</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'GET_WEATHER_ERROR'</span><span class="pun">,</span><span class="pln">
      error</span><span class="pun">:</span><span class="pln"> result</span><span class="pun">.</span><span class="pln">error</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'GET_WEATHER_SUCCESS'</span><span class="pun">,</span><span class="pln">
    payload</span><span class="pun">:</span><span class="pln"> result</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><strong>3. redux-composable-fetch</strong></p>
<p>在实际应用中，我们还需要加上 loading 状态。结合上述讨论的两个开源 middleware，我们完全可以自己实现一个更贴合工程需要的 middleware，这里将其命名为 redux-composable-fetch。</p>
<p>在理想情况下，我们不希望通过复杂的方法去请求数据，而希望通过如下形式一并完成在异步请求过程中的不同状态：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pun">{</span><span class="pln">
  url</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/api/weather.json'</span><span class="pun">,</span><span class="pln">
  </span><span class="kwd">params</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    city</span><span class="pun">:</span><span class="pln"> encodeURI</span><span class="pun">(</span><span class="pln">city</span><span class="pun">),</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
  types</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="str">'GET_WEATHER'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'GET_WEATHER_SUCESS'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'GET_WEATHER_ERROR'</span><span class="pun">],</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>可以看到，异步请求 action 的格式有别于 FSA。它并没有使用 <code>type</code> 属性，而使用了 <code>types</code> 属性。<code>types</code> 其实是三个普通 action <code>type</code> 的集合，分别代表请求中、请求成功和请求失败。</p>
<p>在请求 middleware 中，会对 action 进行格式检查，若存在 <code>url</code> 和 <code>types</code> 属性，则说明这个 action 是一个用于发送异步请求的 action。此外，并不是所有请求都能携带参数，因此 <code>params</code> 是可选的。</p>
<p>当请求 middleware 识别到这是一个用于发送请求的 action 后，首先会分发一个新的 action，这个 action 的 <code>type</code> 就是原 action 里 <code>types</code> 数组中的第一个元素，即请求中。分发这个新 action 的目的在于让 store 能够同步当前请求的状态，如将 loading 状态置为 <code>true</code>，这样在对应的界面上可以展示一个友好的加载中动画。</p>
<p>然后，请求 middleware 会根据 action 中的 <code>url</code>、<code>params</code>、<code>method</code> 等参数发送一个异步请求，并在请求响应后根据结果的成功或失败分别分发请求成功或请求失败的新 action。</p>
<p>请求 middleware 的简化实现如下，我们可以根据具体的场景对此进行改造：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> fetchMiddleware </span><span class="pun">=</span><span class="pln"> store </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">action</span><span class="pun">.</span><span class="pln">url </span><span class="pun">||</span><span class="pln"> </span><span class="pun">!</span><span class="typ">Array</span><span class="pun">.</span><span class="pln">isArray</span><span class="pun">(</span><span class="pln">action</span><span class="pun">.</span><span class="pln">types</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">[</span><span class="pln">LOADING</span><span class="pun">,</span><span class="pln"> SUCCESS</span><span class="pun">,</span><span class="pln"> ERROR</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> action</span><span class="pun">.</span><span class="pln">types</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">next</span><span class="pun">({</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> LOADING</span><span class="pun">,</span><span class="pln">
    loading</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">...</span><span class="pln">action</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">

  fetch</span><span class="pun">(</span><span class="pln">action</span><span class="pun">.</span><span class="pln">url</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">params</span><span class="pun">:</span><span class="pln"> action</span><span class="pun">.</span><span class="kwd">params</span><span class="pln"> </span><span class="pun">})</span><span class="pln">
    </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">result </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">next</span><span class="pun">({</span><span class="pln">
        type</span><span class="pun">:</span><span class="pln"> SUCCESS</span><span class="pun">,</span><span class="pln">
        loading</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
        payload</span><span class="pun">:</span><span class="pln"> result</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">})</span><span class="pln">
    </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">err </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">next</span><span class="pun">({</span><span class="pln">
        type</span><span class="pun">:</span><span class="pln"> ERROR</span><span class="pun">,</span><span class="pln">
        loading</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
        error</span><span class="pun">:</span><span class="pln"> err</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这样我们的确一步就完成了异步请求的 action。</p>
<h3><strong>5.3.2　使用 middleware 处理复杂异步流</strong></h3>
<p>在实际场景中，我们不但有短连接请求，还有轮询请求、多异步串联请求，或是在异步中加入同步处理的逻辑。这时候，使用 redux-composable-fetch 就显得力不从心了。</p>
<p><strong>1. 轮询</strong></p>
<p>轮询是长连接的一种实现方式，它能够在一定时间内重新启动自身，然后再次发起请求。基于这个特性，我们可以在 redux-composable-fetch 的基础上再写一个 middleware，这里命名为 redux-polling：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> setRafTimeout</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> clearRafTimeout </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'setRafTimeout'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="pun">({</span><span class="pln"> dispatch</span><span class="pun">,</span><span class="pln"> getState </span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> pollingUrl</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">params</span><span class="pun">,</span><span class="pln"> types </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> action</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> isPollingAction </span><span class="pun">=</span><span class="pln"> pollingUrl </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">params</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> types</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">isPollingAction</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">let</span><span class="pln"> timeoutId </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">const</span><span class="pln"> startPolling </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">timeout </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    timeoutId </span><span class="pun">=</span><span class="pln"> setRafTimeout</span><span class="pun">(()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> pollingUrl</span><span class="pun">,</span><span class="pln"> </span><span class="pun">...</span><span class="pln">others </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> action</span><span class="pun">;</span><span class="pln">

      </span><span class="kwd">const</span><span class="pln"> pollingAction </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="pun">...</span><span class="pln">others</span><span class="pun">,</span><span class="pln">
        url</span><span class="pun">:</span><span class="pln"> pollingUrl</span><span class="pun">,</span><span class="pln">
        timeoutId</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">};</span><span class="pln">

      dispatch</span><span class="pun">(</span><span class="pln">pollingAction</span><span class="pun">).</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">data </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">data </span><span class="pun">&amp;&amp;</span><span class="pln"> data</span><span class="pun">.</span><span class="pln">interval </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">typeof</span><span class="pln"> data</span><span class="pun">.</span><span class="pln">interval </span><span class="pun">===</span><span class="pln"> </span><span class="str">'number'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          startPolling</span><span class="pun">(</span><span class="pln">data</span><span class="pun">.</span><span class="pln">interval </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1000</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          console</span><span class="pun">.</span><span class="pln">error</span><span class="pun">(</span><span class="str">'pollingAction should fetch data contain interval'</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">},</span><span class="pln"> timeout</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  startPolling</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> clearPollingTimeout </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">timeoutId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">timeoutId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    clearRafTimeout</span><span class="pun">(</span><span class="pln">timeoutId</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>在这个 middleware 的实现中，我们用到了 <code>raf</code> 函数，在 2.7 节中我们已经提到过它。<code>raf</code> 是实现中的关键点之一，它可以让请求在一定时间内重新发起。</p>
<p>另外，在 API 的设计上，我们还暴露了 <code>clearPollingTimeout</code> 方法，以便我们在需要时手动停止轮询。</p>
<p>最后，调用 action 来发起轮询：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pun">{</span><span class="pln">
  pollingUrl</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/api/weather.json'</span><span class="pun">,</span><span class="pln">
  </span><span class="kwd">params</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    city</span><span class="pun">:</span><span class="pln"> encodeURI</span><span class="pun">(</span><span class="pln">city</span><span class="pun">),</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
  types</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="str">'GET_WEATHER_SUCESS'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">],</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>至于长连接，还有其他多种实现方式，最好的方式是对其整体做一次封装，在内部实现诸如轮询和 WebSocket。</p>
<p><strong>2. 多异步串联</strong></p>
<p>多异步串联是我们在应用场景中常见的逻辑，根据以往的经验，是不是很快就想到用 promise 去实现。</p>
<p>我们试想，通过对 promise 封装是不是能够做到不论是否是异步请求，都通过 promise 来传递以达到一个统一的效果。的确，这一点非常容易就可以实现：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> sequenceMiddleware </span><span class="pun">=</span><span class="pln"> </span><span class="pun">({</span><span class="pln">dispatch</span><span class="pun">,</span><span class="pln"> getState</span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> action </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="typ">Array</span><span class="pun">.</span><span class="pln">isArray</span><span class="pun">(</span><span class="pln">action</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">(</span><span class="pln">action</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> action</span><span class="pun">.</span><span class="pln">reduce</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln">result</span><span class="pun">,</span><span class="pln"> currAction</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> result</span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">.</span><span class="pln">isArray</span><span class="pun">(</span><span class="pln">currAction</span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln">
        </span><span class="typ">Promise</span><span class="pun">.</span><span class="pln">all</span><span class="pun">(</span><span class="pln">currAction</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">item </span><span class="pun">=&gt;</span><span class="pln"> dispatch</span><span class="pun">(</span><span class="pln">item</span><span class="pun">)))</span><span class="pln"> </span><span class="pun">:</span><span class="pln">
        dispatch</span><span class="pun">(</span><span class="pln">currAction</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">},</span><span class="pln"> </span><span class="typ">Promise</span><span class="pun">.</span><span class="pln">resolve</span><span class="pun">());</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这里我们定义了一个名为 <code>sequenceMiddleware</code> 的 middleware。在构建 action creator 时，会传递一个数组，数组中每一个值都将是按顺序执行的步骤。这里的步骤既可以是异步的，也可以是同步的。</p>
<p>在实现过程中，我们非常巧妙地使用 <code>Promise.resolve()</code> 来初始化 <code>action.reduce</code> 方法，然后始终使用 <code>Promise.then()</code> 方法串联起数组，达到了串联步骤的目的。</p>
<p>这里还是使用之前的例子。假设我们的应用初始化时会先获取当前城市，然后获取当前城市的天气信息，那么就可以这么写：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">function</span><span class="pln"> getCurrCity</span><span class="pun">(</span><span class="pln">ip</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    url</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/api/getCurrCity.json'</span><span class="pun">,</span><span class="pln">
    </span><span class="kwd">params</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> ip </span><span class="pun">},</span><span class="pln">
    types</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="str">'GET_CITY_SUCCESS'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">],</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> getWeather</span><span class="pun">(</span><span class="pln">cityId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    url</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/api/getWeatherInfo.json'</span><span class="pun">,</span><span class="pln">
    </span><span class="kwd">params</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> cityId </span><span class="pun">},</span><span class="pln">
    types</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="str">'GET_WEATHER_SUCCESS'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">],</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> loadInitData</span><span class="pun">(</span><span class="pln">ip</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">[</span><span class="pln">
    getCurrCity</span><span class="pun">(</span><span class="pln">ip</span><span class="pun">),</span><span class="pln">
    </span><span class="pun">(</span><span class="pln">dispatch</span><span class="pun">,</span><span class="pln"> state</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      dispatch</span><span class="pun">(</span><span class="pln">getWeather</span><span class="pun">(</span><span class="pln">getCityIdWithState</span><span class="pun">(</span><span class="pln">state</span><span class="pun">)));</span><span class="pln">
    </span><span class="pun">},</span><span class="pln">
  </span><span class="pun">];</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这种方法利用了数组的特性。可以看到，它已经覆盖了大部分场景。当然，如果串联过程中有不同的分支，就无能为力了。</p>
<p><strong>3. redux-saga</strong></p>
<p>在 Redux 社区，还有一个处理异步流的后起之秀，名为 redux-saga。它与上述方法最直观的不同就是用 generator 替代了 promise，我们通过 Babel 可以很方便地支持 generator：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">function</span><span class="pun">*</span><span class="pln"> getCurrCity</span><span class="pun">(</span><span class="pln">ip</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> data </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">yield</span><span class="pln"> call</span><span class="pun">(</span><span class="str">'/api/getCurrCity.json'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> ip </span><span class="pun">});</span><span class="pln">

  </span><span class="kwd">yield</span><span class="pln"> put</span><span class="pun">({</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'GET_CITY_SUCCESS'</span><span class="pun">,</span><span class="pln">
    payload</span><span class="pun">:</span><span class="pln"> data</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pun">*</span><span class="pln"> getWeather</span><span class="pun">(</span><span class="pln">cityId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> data </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">yield</span><span class="pln"> call</span><span class="pun">(</span><span class="str">'/api/getWeatherInfo.json'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> cityId </span><span class="pun">});</span><span class="pln">

  </span><span class="kwd">yield</span><span class="pln"> put</span><span class="pun">({</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'GET_WEATHER_SUCCESS'</span><span class="pun">,</span><span class="pln">
    payload</span><span class="pun">:</span><span class="pln"> data</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> loadInitData</span><span class="pun">(</span><span class="pln">ip</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">yield</span><span class="pln"> getCurrCity</span><span class="pun">(</span><span class="pln">ip</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">yield</span><span class="pln"> getWeather</span><span class="pun">(</span><span class="pln">getCityIdWithState</span><span class="pun">(</span><span class="pln">state</span><span class="pun">));</span><span class="pln">
  </span><span class="kwd">yield</span><span class="pln"> put</span><span class="pun">({</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'GET_DATA_SUCCESS'</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>redux-saga 的确是最优雅的通用解决方案，它有着灵活而强大的协程机制，可以解决任何复杂的异步交互。要想深入学习 redux-sage，请参考官方文档。</p>
<h2><strong>5.4　Redux 与路由</strong></h2>
<p>要开发一个富客户端应用，有一样东西是必不可少的——路由（router）系统。</p>
<p>在过去，路由是服务端专有的部分。自从富客户端应用越来越广泛地出现在 Web 上，我们已经不能忽视前后端之间发生的巨大变化。SPA 应用也不例外，可以说，所有 SPA 都必然会由一个路由系统作为整个系统的入口。</p>
<p>在 React 的生态环境中，React Router 是公认的最优秀的路由解决方案。它提供了与 React 思想十分贴合的声明式的路由系统。我们可以通过 <code>&lt;Router&gt;</code> 、 <code>&lt;Route&gt;</code> 这两个标签以及一系列属性定义整个 React 应用的路由方案。</p>
<p>然而在 Redux 应用中，我们遇到了一些新的问题。其中最迫切的问题是，应用程序的所有状态都应该保存在一个单一的 store 中，而当前的路由状态很明显也属于应用状态的一部分。如果直接使用 React Router，就意味着所有路由相关的信息脱离了 Redux store 的控制，这样就违背了 Redux 的设计思想，也给我们的应用带来了更多的不确定性。</p>
<p>所以，我们需要一个这样的路由系统，它既能利用 React Router 的声明式特性，又能将路由信息整合进 Redux store 中。</p>
<p>本节中，我们将详细为大家介绍 React Router 和 react-router-redux 的使用方式、工作原理及最佳实践。</p>
<h3><strong>5.4.1　React Router</strong></h3>
<p>我们知道，React 不是一个前端应用框架，因此不像 Angular.js 或者 Ember.js 等集成了开发者可能需要的各种各样的功能，你必须选择符合自己需求且必要的部件才能打造一个完整的前端单页应用。</p>
<p>而说到和 React 应用搭配的路由系统，非 React Router 莫属。事实上，React Router 在 GitHub 上的代码库已经和 React 一样都归属于 reactjs Group 下。从某种意义上来说，React Router 已经成为官方认证的路由库了。</p>
<p><strong>1. 路由的基本原理</strong></p>
<p>简单地说，路由的基本原理即是保证 View 和 URL 同步，而 View 可以看成是资源的一种表现。当用户在 Web 界面中进行操作时，应用会在若干个交互状态中切换，路由则会记录下某些重要的状态，比如在博客系统中用户是否登录、访问哪一篇文章、位于文章归档列表的第几页等。</p>
<p>这些变化同样会被记录在浏览器的历史中，用户可以通过浏览器的“前进”、“后退”按钮切换状态，同样可以将 URL 分享给好友。简单地说，用户可以通过手动输入或者与页面进行交互来改变 URL，然后通过同步或者异步的方式向服务端发送请求获取资源，重新绘制 UI，如图 5-5 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.005.png" alt="" width="85%" style="width: 85%"></p>
<p><strong>图 5-5　React Router 流程图</strong></p>
<p>那么，React Router 和其他前端路由有什么区别呢？</p>
<p><strong>2. React Router 的特性</strong></p>
<p>React Router 中的很多特性都与 React 保持一致。回想一下，在 React 中，组件就是一个方法。props 作为方法的参数，当它们发生变化时会触发方法执行，进而帮助我们重新绘制 View。在 React Router 中，我们同样可以把 Router 组件看成一个方法，location 作为参数，返回的结果同样是 View，如图 5-6 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.006.png" alt="" width="90%" style="width: 90%"></p>
<p><strong>图 5-6　React Router 与 React 对比</strong></p>
<ul>
<li><p><strong>声明式的路由</strong></p>
<p>从图 5-6 中，我们很自然就可以联想到，React 带给我们最特别的编程体验就是声明式编程，所有的交互逻辑都在 <code>render</code> 返回的 JSX 标签中得到体现。而 React Router 很好地继承了 React 的这一特点，允许开发者使用 JSX 标签来书写声明式的路由。下面是一个简单的例子：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Router</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Route</span><span class="pun">,</span><span class="pln"> browserHistory </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">const</span><span class="pln"> routes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="typ">Router</span><span class="pln"> history</span><span class="pun">={</span><span class="pln">browserHistory</span><span class="pun">}&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">Route</span><span class="pln"> path</span><span class="pun">=</span><span class="str">"/"</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">App</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="typ">Router</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>不用过多解释，我们就可以看出当前页面 <code>url</code> 为 <code>/</code> 时，React Router 会帮我们渲染 App 这个组件。</p>
<p>当然，这只是最简单的路由情况，实际应用中路由配置会比这复杂得多。由于声明式标签原生的表述能力，我们依然能够在最短的时间内对整个应用的路由设计有一个全面的了解。</p>
</li>
<li><p><strong>嵌套路由及路径匹配</strong></p>
<p>在许多复杂的单页应用中，嵌套路由是再常见不过的设计了。以 Gmail 为例，当我们打开首页时，页面上会展示一个顶栏、一个侧边栏和一个收件箱列表。而当点击某封具体的邮件时，界面上依然展示了顶栏和侧边栏，唯一不同的是收件箱列表变成了邮件详情。</p>
<p>而 React Router 为这种嵌套的情况提供了良好的支持：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Router</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Route</span><span class="pun">,</span><span class="pln"> </span><span class="typ">IndexRoute</span><span class="pun">,</span><span class="pln"> browserHistory </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">const</span><span class="pln"> routes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="typ">Router</span><span class="pln"> history</span><span class="pun">={</span><span class="pln">browserHistory</span><span class="pun">}&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">Route</span><span class="pln"> path</span><span class="pun">=</span><span class="str">"/"</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">App</span><span class="pun">}&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">IndexRoute</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">MailList</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Route</span><span class="pln"> path</span><span class="pun">=</span><span class="str">"/mail/:mailId"</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">Mail</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">&lt;/</span><span class="typ">Route</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="typ">Router</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>在这个路由配置中，App 组件承载了显示顶栏和侧边栏的功能，而 React Router 会根据当前的 <code>url</code> 自动判断该显示邮件列表页还是详情页：</p>
<ul>
<li><p>当 <code>url</code> 为 <code>/</code> 时，显示列表页；</p>
</li>
<li><p>当 <code>url</code> 为 <code>/mail/123</code> 时，显示详情页。</p>
</li>
</ul>
<p>那么，在声明路由的时候，怎么知道 <code>url</code> 里 <code>mailId</code> 会是 123 还是 456 呢？这就要说到 React Router 的路径匹配特性了。</p>
<p>在声明路由时，<code>path</code> 属性指明了当前路由匹配的路径形式。若某条路由需要参数，只用简单地加上 <code>:参数名</code> 即可。若这个参数是可选参数，则用括号套起来 <code>(:可选参数)</code>。</p>
</li>
<li><p><strong>支持多种路由切换方式</strong></p>
<p>我们都知道路由切换无外乎使用 <code>hashChange</code> 或是 <code>history.pushState</code>。<code>hashChange</code> 的方式拥有良好的浏览器兼容性，但是 <code>url</code> 中却多了丑陋的 <code>/#/</code> 部分；而 <code>history.pushState</code> 方法则能给我们提供优雅的 <code>url</code>，却需要额外的服务端配置解决任意路径刷新的问题。</p>
<p>因此，React Router 提供了两种解决方案供你根据自己的业务需求进行挑选。这也是为什么我们的路由配置中需要从 <code>react-router</code> 引入 <code>browserHistory</code> 并将其当作 props 传给 Router 。</p>
<p><code>browserHistory</code> 即 <code>history.pushState</code> 的实现，假如想使用 <code>hashChange</code> 的方式改变路由，从 React Router 中使用<code>import hashHistory</code> 即可。</p>
</li>
</ul>
<h3><strong>5.4.2　React Router Redux</strong></h3>
<p>在 Redux 刚刚兴起的时候，社区中就出现了与之配套的解决方案 Redux Router，它基于 React Router，利用高阶组件的概念实现了路由状态与 Redux store 的绑定。然而由于 Redux Router 设计得非常烦琐，引入了太多的 API，所以学习和整合的难度太大，逐渐被 Redux Simple Router 所取代。</p>
<p>然而就在本书编写时，React Router 发布了 2.0.0 版本，在这一版中提供了对 Redux 应用的支持。同时，Redux Simple Router 也更名为 React Router Redux。</p>
<p>既然 React Router 已经这么强大，为什么我们还需要 React Router Redux 呢？正如我们在上一章中提到的，React Router Redux 的前身是 Redux Simple Router，它的职责主要是将应用的路由信息与 Redux 中的 store 绑定在一起。你可能会好奇为什么要这么做？</p>
<p>答案很简单。因为对于前端应用来说，路由状态（当前切换到了哪个页面，当前页面的参数有哪些，等等）也是应用状态的一部分。在很多情况下，我们的业务逻辑与路由状态有很强的关联关系。比如，最常见的一个列表页中，分页参数、排序参数可能都会在路由中体现，而这些参数的改变必然导致列表中的数据发生变化。</p>
<p>因此，当我们采用 Redux 架构时，所有的应用状态必须放在一个单一的 store 中管理，路由状态也不例外。而这就是 React Router Redux 为我们实现的主要功能。</p>
<p><strong>1. 将 React Router 与 Redux store 绑定</strong></p>
<p>React Router Redux 提供了简单直白的 API——<code>syncHistoryWithStore</code> 来完成与 Redux store 的绑定工作。我们只需要传入 React Router 中的 <code>history</code>（前面提到的 <code>browserHistory</code> 或 <code>hashHistory</code>，甚至是自己创建的 <code>history</code>），以及 Redux 中的 store，就可以获得一个增强后的 <code>history</code> 对象。</p>
<p>将这个 <code>history</code> 对象传给 React Router 中的 <code>&lt;Router&gt;</code> 组件作为 props，就给 React Router Redux 提供了观察路由变化并改变 store 的能力（反之亦然）：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> browserHistory </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> syncHistoryWithStore </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> reducers </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'&lt;project-path&gt;/reducers'</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> store </span><span class="pun">=</span><span class="pln"> createStore</span><span class="pun">(</span><span class="pln">reducers</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> history </span><span class="pun">=</span><span class="pln"> syncHistoryWithStore</span><span class="pun">(</span><span class="pln">browserHistory</span><span class="pun">,</span><span class="pln"> store</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p><strong>2. 用 Redux 的方式改变路由</strong></p>
<p>无论是 Flux 还是 Redux，想要改变数据，必须要分发一个 action。前面又讲到了，路由状态作为应用状态数据的必要性。那么，在 Redux 应用中需要改变路由时，是不是也要分发一个 action 呢？答案是肯定的。</p>
<p>但是在这之前，我们需要对 Redux 的 store 进行一些增强，以便分发的 action 能被正确识别：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> browserHistory </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> routerMiddleware </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> middleware </span><span class="pun">=</span><span class="pln"> routerMiddleware</span><span class="pun">(</span><span class="pln">browserHistory</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> store </span><span class="pun">=</span><span class="pln"> createStore</span><span class="pun">(</span><span class="pln">
  reducers</span><span class="pun">,</span><span class="pln">
  applyMiddleware</span><span class="pun">(</span><span class="pln">middleware</span><span class="pun">)</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>首先，我们引入了 React Router Redux 提供的 <code>routerMiddleware</code>，它实际上是一个 middleware 工厂，传入 <code>history</code> 对象，返回一个真正的 Redux middleware。最终，在创建 Redux store 时，我们将这个 middleware 启用并作为第二个参数传入 <code>createStore</code> 方法，获得被 React Router Redux 加工过的新 store。</p>
<p>最后，就可以用 <code>store.dispatch</code> 来分发一个路由变动的 action 了：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> push </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pun">;</span><span class="pln">

</span><span class="com">// 切换路由到 /home</span><span class="pln">
store</span><span class="pun">.</span><span class="pln">dispatch</span><span class="pun">(</span><span class="pln">push</span><span class="pun">(</span><span class="str">'/home'</span><span class="pun">));</span><span class="pln">
</span></code></pre>
<p>React Router 是一个“多变”的路由库，在 1.0 正式版之前，每一个小版本都会有大量的 API 变动，这也对开发者们的开发体验造成了极大的痛苦。但不论它怎么变，只要我们熟练掌握了其中的原理，就可以以不变应万变。</p>
<h2><strong>5.5　Redux 与组件</strong></h2>
<p>我们在 4.1 节中提到了两种类型的组件，一种是容器型组件，这种命名在第1章中提到过，另一种是展示型组件。要区分它们，主要是看是否有数据操作。</p>
<p>在早期 Redux 版本中，作者将上述两种组件定义为 Smart 和 Dumb 组件，但是这个名字过于晦涩。为了可以通过名字清晰地区分出两者的不同，新名字就应运而生了。</p>
<p>本节中，我们就来讨论一下这两种组件的定义与应用场景，以及与 Redux 的关系。</p>
<h3><strong>5.5.1　容器型组件</strong></h3>
<p>容器型组件，意为组件是怎么工作的，更具体一些就是数据是怎么更新的。它不会包含任何 Virtual DOM 的修改或组合，也不会包含组件的样式。</p>
<p>如果映射到 Flux 上，那么容器型组件就是与 store 作绑定的组件。如果映射到 Redux 上，那么容器型组件就是使用 connect 的组件。因此，我们都在这些组件里作了数据更新的定义。</p>
<h3><strong>5.5.2　展示型组件</strong></h3>
<p>展示型组件，意为组件是怎么渲染的。它包含了 Virtual DOM 的修改或组合，也可能包含组件的样式。同时，它不依赖任何形式的 store。一般可以写成无状态函数，但实际上展示型组件并不一定都是无状态的组件，因为很多展示型组件里依然存在生命周期方法。</p>
<p>这样做区分的目的是为了可以使用相同的展示型组件来配合不同的数据源作渲染，可以做到更好的可复用性。另外，展示型组件可以让设计师不用关心应用的逻辑，去随时尝试不同的组合。</p>
<h3><strong>5.5.3　Redux 中的组件</strong></h3>
<p>关于容器型组件和展示型组件，Redux 官方文档给出了对比结果，如表 5-1 所示。</p>
<p><strong>表 5-1　对比容器型组件和展示型组件</strong></p>
<table width="90%" border="1">
<thead>
<tr>
<th><p class="表头单元格">&nbsp;</p></th>
<th><p class="表头单元格">展示型组件</p></th>
<th><p class="表头单元格">容器型组件</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><p class="表格单元格">目的</p></td>
<td><p class="表格单元格">长什么样子 （标签、样式等）</p></td>
<td><p class="表格单元格">干什么用 （获取数据、更新状态等）</p></td>
</tr>
<tr>
<td><p class="表格单元格">是否感知 Redux</p></td>
<td><p class="表格单元格">否</p></td>
<td><p class="表格单元格">是</p></td>
</tr>
<tr>
<td><p class="表格单元格">要获取数据</p></td>
<td><p class="表格单元格">从 <code>this.props</code> 中获取</p></td>
<td><p class="表格单元格">使用 <code>connect</code> 从 Redux 状态树中获取</p></td>
</tr>
<tr>
<td><p class="表格单元格">要改变数据</p></td>
<td><p class="表格单元格">调用从 props 中传入的 action creator</p></td>
<td><p class="表格单元格">直接分发任意 action</p></td>
</tr>
<tr>
<td><p class="表格单元格">实际创建于</p></td>
<td><p class="表格单元格">开发者自身</p></td>
<td><p class="表格单元格">通常由 React Redux 创建</p></td>
</tr>
</tbody>
</table>
<p>从布局的角度来看，在Redux中，强调了 3 种不同类型的布局组件：Layouts、Views和Components。它们与容器型组件和展示型组件有着怎样的对应关系呢？</p>
<p><strong>1. Layouts</strong></p>
<p>Layouts 指的是页面布局组件，描述了页面的基本结构，目的是将主框架与页面主体内容分离。它常常是无状态函数，传入主体内容的 <code>children</code> 属性。结合 5.4 节的内容，Layout 组件就是设置在最外层 Route 中的 <code>component</code> 里。一般 Layout 的写法如下：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">Layout</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">({</span><span class="pln"> children </span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">=</span><span class="str">'container'</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">Header</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">=</span><span class="str">"content"</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">{</span><span class="pln">children</span><span class="pun">}</span><span class="pln">
    </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p><strong>2. Views</strong></p>
<p>Views 指的是子路由入口组件，描述了子路由入口的基本结构，包含此路由下所有的展示型组件。为了保持子组件的纯净，我们在这一层组件中定义了数据和 action 的入口，从这里开始将它们分发到子组件中去。因此，Views 就是 Redux 中的容器型组件。一般 Views 的写法如下：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="lit">@connect</span><span class="pun">((</span><span class="pln">state</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">//...</span><span class="pln">
</span><span class="pun">})</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">HomeView</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> sth</span><span class="pun">,</span><span class="pln"> changeType </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> cardProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> sth</span><span class="pun">,</span><span class="pln"> changeType </span><span class="pun">};</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">=</span><span class="str">"page page-home"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">Card</span><span class="pln"> </span><span class="pun">{...</span><span class="pln">cardProps</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><strong>3. Components</strong></p>
<p>顾名思义，Components 就是末级渲染组件，描述了从路由以下的子组件。它们包含具体的业务逻辑和交互，但所有的数据和 action 都是由 Views 传下来的，这也意味着它们是可以完全脱离数据层而存在的展示型组件。一般由路由传下来的 Components 的写法如下：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">Card</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Components</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleChange</span><span class="pun">(</span><span class="pln">opts</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> type </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> opts</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">changeType</span><span class="pun">(</span><span class="pln">type</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> sth </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">=</span><span class="str">"mod-card"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">Switch</span><span class="pln"> onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}&gt;</span><span class="pln">
          </span><span class="com">// ...</span><span class="pln">
        </span><span class="pun">&lt;/</span><span class="typ">Switch</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">sth</span><span class="pun">}</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>通过上述 3 种组件的定义，我们看到 Redux 中对页面布局的区分，以及页面的基本结构与数据传递的形式。这么做是为了更好地利用 React 组件的可复用性。</p>
<p>从第 2 章到本节，我们对于 React 组件的解释终于趋于完整。对于我们来说，分清楚这些概念尤为重要。除了上述的容器型组件和展示型组件外，还有有状态（stateful）组件和无状态（stateless）组件、类（class）和方法（function）、纯（pure）组件和非纯（impure）组件。</p>
<h2><strong>5.6　Redux 应用实例</strong></h2>
<p>为了充分了解 Redux 架构在实际项目中的应用，我们准备了一个全新的 Redux SPA 示例——一个包含文章列表和文章详情等页面的简易博客系统。</p>
<p>在这个示例中，我们将会接触到 Redux 所有的知识点，并将其串联在一起作完整的解释。</p>
<h3><strong>5.6.1　初始化 Redux 项目</strong></h3>
<p>首先，我们从项目初始化说起。这必须从新建目录开始。新建 redux-blog 目录，用于保存整个博客系统的所有内容，包括源码、依赖、构建脚本等：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">$ mkdir redux</span><span class="pun">-</span><span class="pln">blog </span><span class="pun">&amp;&amp;</span><span class="pln"> cd redux</span><span class="pun">-</span><span class="pln">blog
</span></code></pre>
<p>像初始化 React 项目那样，我们需要新增一个 package.json 文件，用于描述项目的基本信息以及项目需要的各种依赖。由于我们不需要将这个项目发布给其他人使用，所以在初始化的过程中不需要填写太多信息。</p>
<p>接着，需要安装一些必要的依赖：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">$ npm install </span><span class="pun">--</span><span class="pln">save react react</span><span class="pun">-</span><span class="pln">dom redux react</span><span class="pun">-</span><span class="pln">router react</span><span class="pun">-</span><span class="pln">redux react</span><span class="pun">-</span><span class="pln">router</span><span class="pun">-</span><span class="pln">redux whatwg</span><span class="pun">-</span><span class="pln">fetch
</span></code></pre>
<p>可以看到，除了最基本的 React、Redux 和 react-redux 外，我们还安装了讨论过的路由库 react-router 和 react-router-redux。此外，还有 Ajax 请求兼容库 whatwg-fetch。</p>
<h3><strong>5.6.2　划分目录结构</strong></h3>
<p>安装完依赖后，我们的目录结构是这样的：</p>
<p>.<br>├── node_modules<br>└── package.json</p>
<p>一般来说，我们希望把所有的源文件放在 src/ 目录下，把测试文件放在 test/ 目录下，而最终生成的、供 HTML 引用的文件放在 build/ 目录下：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">$ mkdir src
$ mkdir test
$ mkdir build
</span></code></pre>
<p>接下来的初始化工作会比较头疼，那就是 src/ 目录下的源代码该怎样组织。</p>
<p>在大部分的 Redux 应用例子中，我们都使用了根据类型划分的文件结构（file structure based type），其形式大致如下：</p>
<p>src/<br>├── app.js<br>├── actions<br>│　　├── XXAction.js<br>│　　└── YYAction.js<br>├── componets<br>│　　├── XXComponent.js<br>│　　└── YYComponent.js<br>├── constants<br>│　　├── XXConstants.js<br>│　　└── YYConstants.js<br>└── reducers<br>　　　├── XXReducer.js<br>　　　└── YYReducer.js</p>
<p>在一些功能简单的 Redux 应用中，推荐这样划分。然而在大型应用中，一般会存在多个页面，每个页面下的 components、actions 和 reducers 都少有交集，这时如果还是简单的根据类型划分文件结构，就会导致单个文件夹下文件过多，在开发中难以快速定位某个文件。</p>
<p>因此，在多个 Redux 项目实践的基础上，我们将在示例博客项目中使用混合方式划分文件结构，既采用了类型划分的优势，又添加了功能划分（file structure based feature）的特点。</p>
<p>src/　　　　　　　　　　　　　　　所有源代码存放的路径<br>├── app.js　　　　　　　　　 　　整个应用的入口<br>├── views　　　 　　　 　　　　　应用中某个页面的入口文件，一般为路由组件<br>│　　├── Home.js　 　　　 　　　例如，首页的入口就是 Home.js<br>│　　├── Home.css　　　　　　　Home 页面对应的样式<br>│　　└── HomeRedux.js　　 　　 Home 页面中所有与 Redux 相关的 reducer、action creator 的汇总，即 components/<br>│　　　　　　　　　　　　　　　　Home/下所有 *Redux.js 的汇总<br>├── components　　　　　　　 　所有应用的组件<br>│　　├── Home 　　　　 　　　　例如，views/ 中一个名为 Home 的 view，则在 components/ 中就有一个名为 Home <br>│　　│　　│　　　　　　　　 　　 的子文件夹<br>│　　│　　├── Table.js　 　　　　Home 页面中的一个列表组件<br>│　　│　　├── Table.css　　 　　 列表组件对应的样式<br>│　　│　　└── TableRedux.js　　 列表组件的 reducer、action creator 及 action type，整合在同一个文件中<br>│　　└── shared　　 　　　 　　　不归属于任何 view 的组件，如一些公共组件等<br>├── containers<br>│　　├── DevTools.js　　　　　　 配置 DevTools<br>│　　└── Root.js　　　 　　 　　　一般被 app.js 依赖，用于根据环境判断是否需要加载 DevTools<br>├── layouts　　　　　　　　　　　布局相关的组件及样式，如菜单、侧边栏、header、footer 等<br>├── redux　　　　　　　　　　　　Redux store 相关的配置<br>│　　└── reducers.js　　　　　　　整个应用中所有 reducer 的汇总<br>├── routes　　　　　　 　　　　 　 路由相关的配置<br>├── utils　　 　 　　　　 　　　　　工具函数、常量等<br>├── styles　　　　　　　　　　　　 全局公共样式<br>└── app.css　　　　　　　　 　　　 应用主样式表</p>
<p>基本上，我们只需要关注的就是 views/ 和 components/ 这两个文件夹，它们也是存放绝大多数业务代码的地方。这里的两个文件夹也正好与上一节提到的 Views 与 Components 两个类型的组件一致。</p>
<p>在 views/ 文件夹中，存放的是每个路由的入口页，如首页（Home）、详情页（Detail）、管理后台页（Admin）等。而每一个入口都会有三个文件：*.js 是入口的组件，*.css 是对应组件的样式，而 *Redux.js 是 components/Home/ 文件夹下所有 reducer 和 action 的聚合。</p>
<p>在 components/Home/ 文件夹里，是当前路由对应的页面（Home）需要的所有内容—— components、actions、reducers、样式等。</p>
<blockquote>
<p><strong>说明</strong>　什么是 *Redux.js？实际上，按照 Redux 应用的一般目录结构划分方式，应该分别有 reducers、action creators 和 constants 文件夹。但是在实际应用中，我们发现这样的划分方式略显烦琐，添加一个组件需要至少新建 4 个文件。同时对于业务应用来说，reducers 等于 Redux 相关的文件并不太可能被其他地方复用，因此放在一个文件里组织并管理是更好的选择。目前，在 Redux 社区中也存在一个类似的规范<span class="注释编号">3</span>。</p>
</blockquote>
<p class="注释内容"><span class="注释编号下">3</span>Ducks modular redux，详见 <a href="https://github.com/erikras/ducks-modular-redux">https://github.com/erikras/ducks-modular-redux</a>。</p>
<h3><strong>5.6.3　设计路由</strong></h3>
<p>在开始具体写代码之前，我们还需要做另外一项非常重要的规划——设计路由。</p>
<p>以我们的博客系统为例，起码需要一个首页来显示文章列表，一个详情页来显示博客内容，一个后台管理页来方便我们对文章数据进行增、删、改、查。</p>
<p>因此，我们分别在 src/views/ 和 src/components/ 下新建对应的文件夹和文件：</p>
<p>src/<br>├── components<br>│　　├── Detail　　　文章详情页<br>│　　└── Home　　　文章列表页<br>└── views<br>　　　├── Detail.css<br>　　　├── Detail.js<br>　　　├── DetailRedux.js<br>　　　├── Home.css<br>　　　├── Home.js<br>　　　└── HomeRedux.js</p>
<p>按照我们的目录结构，所有的路由配置应该放在 src/routes/ 目录下，因此在这个目录下新建 index.js 文件，用来配置整个应用的所有路由信息：</p>
<p>src/<br>├── components<br>├── routes<br>│　　└── index.js<br>└── views</p>
<p>在路由配置文件中，首先应该引入所有需要的依赖：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="com">// routes/index.js</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Router</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Route</span><span class="pun">,</span><span class="pln"> </span><span class="typ">IndexRoute</span><span class="pun">,</span><span class="pln"> hashHistory </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Home</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../views/Home'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Detail</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../views/Detail'</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>接下来，使用 react-router 提供的组件来定义应用的路由：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> routes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="typ">Router</span><span class="pln"> history</span><span class="pun">={</span><span class="pln">hashHistory</span><span class="pun">}&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">Route</span><span class="pln"> path</span><span class="pun">=</span><span class="str">"/"</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">Home</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">Route</span><span class="pln"> path</span><span class="pun">=</span><span class="str">"/detail/:id"</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">Detail</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="typ">Router</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>在上述配置里，我们先告诉 react-router 使用 <code>hashHistory</code> 作为前端路由的实现方式，通过改变 URL 的散列值（<code>#</code> 后面的部分）来实现路由的切换。使用 <code>hashHistory</code> 的好处是实现简单，兼容性好，不需要做额外的服务端改造。</p>
<p>如果追求更好的用户体验，使用 <code>browserHistory</code> 是更好的选择。<code>browserHistory</code> 使用的是 HTML5 的 <code>pushState</code> API。这种技术也有一定的局限性，首先需要服务器端将所有的请求重定向到首页，其次部分较老的浏览器并不支持 pushState 技术。</p>
<p>为了得到更好的兼容性，我们在实例项目中选择 <code>hashHistory</code>。</p>
<p>接下来是我们熟悉的标签嵌套语法，在 <code>&lt;Router&gt;</code> 标签内部，是两个 <code>&lt;Route&gt;</code> 标签，它们代表着我们定义的两条路由记录，对应的目录如下：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pun">/</span><span class="pln">               </span><span class="pun">首页，即文章列表页</span><span class="pln">
</span><span class="pun">/</span><span class="pln">detail</span><span class="pun">/:</span><span class="pln">id     </span><span class="pun">文章详情页</span><span class="pln">
</span></code></pre>
<p>每条路由信息都包含了对应的路径和需要渲染的组件。可以看到，这些组件就是我们在 views/ 文件夹中定义的路由入口页组件。</p>
<p>最后，为了能最快看到效果，我们将 views/ 下的所有路由入口组件初始化为只渲染标题的 React 组件。以 Home 组件为例，src/views/Home.js 文件中的代码如下：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Home</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;h1&gt;</span><span class="typ">Home</span><span class="pun">&lt;/</span><span class="pln">h1</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="typ">Home</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>Detail.js 同理，这里不再详述。</p>
<h3><strong>5.6.4　让应用跑起来</strong></h3>
<p>现在我们已经配置好了整个应用的路由，那么该怎么在浏览器中看到效果呢？很显然，我们需要一个应用的入口文件，通常会将其命名为 app.js。</p>
<p>让我们在 src/ 文件夹下新建 app.js：</p>
<p>src/<br>├── app.js<br>├── components<br>├── routes<br>└── views</p>
<p>然后在文件的开头引入需要的依赖。很显然，我们需要 React 来渲染所有的组件。此外，还需要引入刚刚定义的路由结构：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> routes </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./routes/'</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>最后，只需要简单地把路由渲染到 DOM 环境中即可。注意，这里我们并没有直接渲染到 <code>document.body</code> 节点上，而是特别选择了 <code>id</code> 为 <code>root</code> 的节点：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(</span><span class="pln">routes</span><span class="pun">,</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="str">'root'</span><span class="pun">));</span><span class="pln">
</span></code></pre>
<p>React 官方并不推荐将组件渲染到 <code>document.body</code> 上，因为这个节点很可能会被修改，比如动态添加一个 <code>&lt;script&gt;</code> 标签等，这将使 React 的 DOM diff 计算变得更加困难。</p>
<p>到这里，整个 App 的雏形已经完成了，但它只有最基本的路由功能。那么该怎么在浏览器里看到效果呢？没错，我们还需要一个 HTML 页面。</p>
<p>在根目录下再新建一个 index.html 用于加载所有的脚本和样式文件：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="dec">&lt;!DOCTYPE html&gt;</span><span class="pln">
</span><span class="tag">&lt;html&gt;</span><span class="pln">
</span><span class="tag">&lt;head&gt;</span><span class="pln">
  </span><span class="tag">&lt;title&gt;</span><span class="pln">redux blog</span><span class="tag">&lt;/title&gt;</span><span class="pln">
</span><span class="tag">&lt;/head&gt;</span><span class="pln">
</span><span class="tag">&lt;body&gt;</span><span class="pln">
  </span><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">id</span><span class="pun">=</span><span class="atv">"root"</span><span class="tag">&gt;&lt;/div&gt;</span><span class="pln">
  </span><span class="tag">&lt;script</span><span class="pln"> </span><span class="atn">type</span><span class="pun">=</span><span class="atv">"text/javascript"</span><span class="pln"> </span><span class="atn">src</span><span class="pun">=</span><span class="atv">"build/app.bundle.js"</span><span class="tag">&gt;&lt;/script&gt;</span><span class="pln">
</span><span class="tag">&lt;/body&gt;</span><span class="pln">
</span><span class="tag">&lt;/html&gt;</span><span class="pln">
</span></code></pre>
<p>看了上述代码，你肯定会疑惑，为什么加载 JavaScript 脚本的地址是 build/app.bundle.js？这就涉及我们在附录 A 中提到的构建工具 webpack 了，它会把 src/ 目录下的所有文件根据依赖关系打包成一个可供浏览器加载并执行的 JavaScript 文件。</p>
<p>这是构建相关的配置。在附录 A 中，我们会学到如何搭建基本的 React 项目环境，包括使用 nvm 管理 Node.js 版本、使用 Babel 将 ES6 语法编译为兼容性更好的 ES5 代码、使用 Sass 来编写和管理样式等。</p>
<p>但是对于一个完整的前端应用来说，这些准备工作还远远不够。在 Redux SPA 项目中，我们依然使用 webpack 构建。可以说，webpack 已经成为 React 社区中的御用工具。在本节后面我们会提到， Redux 作者开发的 react-transform-hmr 和 react-transform-catch-errors 等都可以方便地整合进 webpack 的构建脚本中使用。</p>
<p>配置 webpack 来实现 SPA 的构建、自动刷新甚至组件热重载以及 ES6 语法转译，与配置 React 应用大同小异，具体可参见附录 A。现在让我们在整个应用的根目录下新建 webpack.config.js 来配置构建工具 webpack：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">var</span><span class="pln"> path </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'path'</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">module</span><span class="pun">.</span><span class="pln">exports </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  entry</span><span class="pun">:</span><span class="pln"> </span><span class="str">'src/app.js'</span><span class="pun">,</span><span class="pln">
  output</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    path</span><span class="pun">:</span><span class="pln"> path</span><span class="pun">.</span><span class="pln">join</span><span class="pun">(</span><span class="pln">__dirname</span><span class="pun">,</span><span class="pln"> </span><span class="str">'build'</span><span class="pun">),</span><span class="pln">
    filename</span><span class="pun">:</span><span class="pln"> </span><span class="str">'app.bundle.js'</span><span class="pun">,</span><span class="pln">
    publicPath</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/build/'</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
  </span><span class="kwd">module</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    loaders</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[{</span><span class="pln">
      test</span><span class="pun">:</span><span class="pln"> </span><span class="str">/\.js$/</span><span class="pun">,</span><span class="pln">
      include</span><span class="pun">:</span><span class="pln"> path</span><span class="pun">.</span><span class="pln">join</span><span class="pun">(</span><span class="pln">__dirname</span><span class="pun">,</span><span class="pln"> </span><span class="str">'src'</span><span class="pun">),</span><span class="pln">
      loader</span><span class="pun">:</span><span class="pln"> </span><span class="str">'babel'</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">}],</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>简单地说，这个配置文件让 webpack 以 src/app.js 为入口，将文件需要的所有依赖打包成一个独立可执行的 JavaScript 文件，并保存到 build/app.bundle.js。此外，当解析 src/ 文件夹下的 .js 文件时，使用 Babel 进行转译。</p>
<p>我们需要一段命令来让 webpack 执行构建命令。因为在后续的教程中会经常使用这段命令，所以我们可以将其写成 <code>npm scripts</code>。打开 package.json，添加 <code>scripts</code> 字段：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pun">{</span><span class="pln">
  </span><span class="str">"scripts"</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="str">"build"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"./node_modules/.bin/webpack"</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>后面就可以通过在终端运行 <code>npm run build</code> 命令来执行我们的构建脚本了：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">$ npm run build

 redux</span><span class="pun">-</span><span class="pln">blog@1</span><span class="pun">.</span><span class="lit">0.0</span><span class="pln"> build </span><span class="pun">/</span><span class="typ">Code</span><span class="pun">/</span><span class="pln">redux</span><span class="pun">-</span><span class="pln">blog
 webpack

</span><span class="typ">Hash</span><span class="pun">:</span><span class="pln"> </span><span class="lit">3b0c35273ffeb406d662</span><span class="pln">
</span><span class="typ">Version</span><span class="pun">:</span><span class="pln"> webpack </span><span class="lit">1.12</span><span class="pun">.</span><span class="lit">14</span><span class="pln">
</span><span class="typ">Time</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1331ms</span><span class="pln">
        </span><span class="typ">Asset</span><span class="pln">    </span><span class="typ">Size</span><span class="pln">  </span><span class="typ">Chunks</span><span class="pln">             </span><span class="typ">Chunk</span><span class="pln"> </span><span class="typ">Names</span><span class="pln">
app</span><span class="pun">.</span><span class="pln">bundle</span><span class="pun">.</span><span class="pln">js  </span><span class="lit">833</span><span class="pln"> kB       </span><span class="lit">0</span><span class="pln">  </span><span class="pun">[</span><span class="pln">emitted</span><span class="pun">]</span><span class="pln">  main
    </span><span class="pun">+</span><span class="pln"> </span><span class="lit">220</span><span class="pln"> hidden modules
</span></code></pre>
<p>一切正常的话，就会发现 build/ 文件夹已经被自动创建，里面有一个全新的文件 app.bundle.js。</p>
<p>接着赶紧用浏览器打开 index.html 看看效果，如图 5-7 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.007.png" alt="{%}"></p>
<p><strong>图 5-7　Redux 应用的执行结果</strong></p>
<p>这个 Redux 应用看起来并不是很高大上，因为看到的只是一个突兀的 <code>&lt;h1&gt;</code> 标签而已。另外，我们注意一下地址栏，当前页面的地址看着也有些奇怪：<a>file:///Code/redux-blog/index.html#/?_k=0e9k95</a>。</p>
<p>因为我们没有在本地启动一个静态文件服务器，所以浏览器用 file:/// 协议解析了 index.html。</p>
<p>比较奇怪的是 <code>#</code> 之后的部分。了解 URL 知识的人应该知道 <code>#</code> 之后的部分称为散列（hash），改变散列值并不会触发页面跳转，而是会在页面中跳转到相应的锚点（若存在的话）。</p>
<p>而对于我们的应用来说，真正的路由信息其实就存在于 <code>#</code> 号之后。实际上，你会在 <code>#</code> 之后看到许多有意思的符号，比如 index.html#/detail/3?mode=1#title 是一个非常典型的前端路由 URL。对于浏览器来说，这段 URL 的散列值是 <code>#/detail/3?mode=1#title</code>，但是 React Router 又对这段散列做了解析，生成了逻辑上的前端路由，包含 <code>path</code>、<code>query</code> 和 <code>hash</code> 等概念。</p>
<p>现在，试试在 <code>#</code> 之后输入下面一段 URL，看看发生了什么：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">index</span><span class="pun">.</span><span class="pln">html</span><span class="com">#/detail</span><span class="pln">
</span></code></pre>
<p>我们发现界面依然很丑，<code>&lt;h1&gt;</code> 标题依然很突兀，但是标题的文字已经从 Home 变成了 Detail，这就是 React Router 带给我们的前端路由系统。</p>
<p>最后还有一点比较奇怪，那段 <code>?_k=0e9k95</code> 是什么？我们知道在 URL 中 <code>?</code> 之后表示的是 query，这段 query 事实上是 React Router 为了提供每一条路由记录持久化数据而生成的唯一标识。如果你不需要这样的特性，也可以使用 React Router 提供的 <code>createHistory</code> 方法创建自定义的 <code>history</code> 对象。</p>
<h3><strong>5.6.5　优化构建脚本</strong></h3>
<p>首先，亟待解决的问题是应用的 URL。很显然，file:/// 并不是一个合适的 URL 前缀。我们知道，一般网站都会采用 HTTP 或 HTTPS 协议来提供 Web 网页，因此需要在本地启动一个 http 服务器以便我们通过 HTTP 协议访问应用。</p>
<p>此外，虽然我们把 webpack 的构建脚本集成到了 <code>npm scripts</code> 中，但是每次修改都需要在终端执行 <code>npm run build</code> 命令也是一种痛苦。如果每次修改源代码时都能自动构建并刷新页面，那将是一种非常好的开发体验。好消息是，这些都可以通过 webpack-dev-server 简单实现。</p>
<p>首先，添加 webpack-dev-server 作为项目的依赖：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">$ npm install </span><span class="pun">-</span><span class="pln">D webpack</span><span class="pun">-</span><span class="pln">dev</span><span class="pun">-</span><span class="pln">server
</span></code></pre>
<p>接下来，将下面的脚本添加到 <code>npm scripts</code> 中，我们后续将用 <code>npm run watch</code> 命令来执行：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pun">.</span><span class="str">/node_modules/</span><span class="pun">.</span><span class="pln">bin</span><span class="pun">/</span><span class="pln">webpack</span><span class="pun">-</span><span class="pln">dev</span><span class="pun">-</span><span class="pln">server </span><span class="pun">--</span><span class="pln">hot </span><span class="pun">--</span><span class="kwd">inline</span><span class="pln"> </span><span class="pun">--</span><span class="pln">content</span><span class="pun">-</span><span class="kwd">base</span><span class="pln"> </span><span class="pun">.</span><span class="pln">
</span></code></pre>
<p>在终端中运行 <code>npm runstart</code>，将会看到 webpack 输出一长串的构建信息。这时打开浏览器，输入 http://localhost:8080/，看看是不是和原来直接用浏览器打开 index.html 看到的效果一模一样？</p>
<blockquote>
<p><strong>说明</strong>　如果没有正常看到页面，该怎么办？确认本地的 8080 端口是否被占用，若是，则可以给 webpack-dev-server 添加 <code>--port 7777</code> 参数来指定自定义的端口。</p>
</blockquote>
<h3><strong>5.6.6　添加布局文件</strong></h3>
<p>虽然我们已经在浏览器中看到了整个应用的雏形，但总觉得哪里还是不对劲。一般来说，一个网站起码会有一个导航栏，用于提供各种链接，而不是让用户手动输入 URL 来实现页面的切换。此外，可能还会有一个公共的页脚，用于显示版权信息、友情链接或者备案信息等。</p>
<p>那么，这些文件应该怎么组织呢？显然，它们应该被放置在布局文件所在的 src/layouts 文件夹下。下面让我们来创建这些文件。</p>
<blockquote>
<p><strong>说明</strong>　为了在浏览器中看到每次代码变动后的效果，我们需要不断执行 <code>npm run build</code> 命令。实际上，可以启动 webpack 的 watch 模式，每当文件发生改变时，自动重新构建。在 package.json 的 <code>scripts</code> 中添加一条新的记录可以解决这个问题：<code>"watch":"./node_modules/.bin/webpack --watch"</code>。然后在终端中执行 <code>npm run watch</code> 命令。</p>
</blockquote>
<p>首先，新建 src/layouts 目录，然后添加两个文件——Frame.js 和 Nav.js：</p>
<p>src/<br>├── components<br>├── layouts<br>│　　├── Frame.js<br>│　　└── Nav.js<br>├── routes<br>└── views</p>
<p>接着我们先看看 Nav.js。顾名思义，这个组件里将会显示所有的导航链接。实际上，它的代码也很简单：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Link</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Nav</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;nav&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">Link</span><span class="pln"> to</span><span class="pun">=</span><span class="str">"/"</span><span class="pun">&gt;</span><span class="typ">Home</span><span class="pun">&lt;/</span><span class="typ">Link</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">nav</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>唯一需要注意的是，我们引入了 React Router 提供的 Link 组件，使用这个组件可以模拟 <code>&lt;a&gt;</code> 标签进行链接跳转。<code>&lt;Link&gt;</code> 的使用方法与 <code>&lt;a&gt;</code> 非常类似，唯一不同的是在指定链接的时候使用 <code>to</code> 属性而不是 <code>href</code>。</p>
<p>接下来，我们还引入了一个新的组件 Frame.js。先看看它长什么样：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Nav</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./Nav'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Frame</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">=</span><span class="str">"frame"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">section className</span><span class="pun">=</span><span class="str">"header"</span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="typ">Nav</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;/</span><span class="pln">section</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">section className</span><span class="pun">=</span><span class="str">"container"</span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">&lt;/</span><span class="pln">section</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>可以看到，Frame 引入了 Nav 组件作为依赖，并将其渲染了出来。此外，Frame 组件还渲染了 <code>this.props.children</code>。</p>
<p>让我们再思考一下我们的页面——文章列表页和详情页，每一个页面的结构都是<strong>导航+具体模块</strong>的结构。当然，我们也可以在每个组件的 <code>render</code> 方法里写入路由，但是这样明显会造成代码的冗余，也没有实现模块之间的关注分离。</p>
<p>所以，我们抽出了 Frame 组件来实现这样的结构。实际上，这也是 layouts/ 文件夹下的组件需要实现的功能。</p>
<p>那么，在 Frame 组件中 <code>this.props.children</code> 代表什么呢？在解释之前，我们需要对 src/routes/index.js 进行一番改造：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Router</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Route</span><span class="pun">,</span><span class="pln"> </span><span class="typ">IndexRoute</span><span class="pun">,</span><span class="pln"> hashHistory </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Frame</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../layouts/Frame'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Home</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../views/Home'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Detail</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../views/Detail'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> routes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="typ">Router</span><span class="pln"> history</span><span class="pun">={</span><span class="pln">hashHistory</span><span class="pun">}&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">Route</span><span class="pln"> path</span><span class="pun">=</span><span class="str">"/"</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">Frame</span><span class="pun">}&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">IndexRoute</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">Home</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Route</span><span class="pln"> path</span><span class="pun">=</span><span class="str">"/detail/:id"</span><span class="pln"> component</span><span class="pun">={</span><span class="typ">Detail</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">&lt;/</span><span class="typ">Route</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="typ">Router</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> routes</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>首先，我们引入了 React Router 提供的另外一个组件 IndexRoute，同时引入了刚刚添加的 layouts 目录下的 Frame 组件。</p>
<p>我们做出的最大改变是，原本并列式的路由声明变成了嵌套式的路由声明。最外层的 <code>&lt;Router&gt;</code> 配置没有变化，<code>/</code> 路由对应的组件不再是 Home，而变成了 Frame。也就是说，当访问 <code>/</code> 路由时，将渲染 Frame 组件。</p>
<p>但是，Frame 组件除了渲染导航之外，并没有渲染任何有意义的东西啊？是的，这就是为什么我们嵌套了一个 <code>&lt;IndexRoute&gt;</code> 组件。 这样的定义表示当访问 <code>/</code> 时，实际渲染的组件是 Frame 和 Home。</p>
<p>在这种情况下， Home 组件就会作为 Frame 组件的子组件。因此，在 Frame 的 <code>render</code> 方法中渲染 <code>this.props.children</code> 时，渲染的其实是 Home 组件。</p>
<p>另外一条路由 <code>/detail/:id</code> 也被定义成了 <code>/</code> 的子路由，这意味着当访问 <code>/detail</code> 时，渲染的是 Frame 和 Detail 组件。</p>
<p>做好了这些修改，打开浏览器再来看看效果，如图 5-8 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.008.png" alt="{%}"></p>
<p><strong>图 5-8　导航效果</strong></p>
<h3><strong>5.6.7　准备首页的数据</strong></h3>
<p>当访问我们的博客时，用户希望看到的自然是文章列表，这也是 Home 组件需要显示的数据。</p>
<p>在 5.6.2 节中我们说到，views/ 文件夹下放着的是所有的路由入口页，而 components/ 下放着的是每个入口页需要的组件、样式以及 Redux 相关的文件。</p>
<p>因此，我们需要在 src/components/Home/ 文件夹下添加几个新文件：</p>
<p>src/<br>├── components<br>│　　├── Detail<br>│　　└── Home<br>│　　　　├── Preview.css<br>│　　　　├── Preview.js<br>│　　　　├── PreviewList.js<br>│　　　　└── PreviewListRedux.js<br>├── layouts<br>├── routes<br>└── views</p>
<p>其中 Preview.js 中定义了一个纯渲染、无状态的文章预览组件：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="str">'./Preview.css'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Preview</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    title</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    link</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">article className</span><span class="pun">=</span><span class="str">"article-preview-item"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">h1 className</span><span class="pun">=</span><span class="str">"title"</span><span class="pun">&gt;{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">title</span><span class="pun">}&lt;/</span><span class="pln">h1</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">span className</span><span class="pun">=</span><span class="str">"date"</span><span class="pun">&gt;{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">date</span><span class="pun">}&lt;/</span><span class="pln">span</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">p className</span><span class="pun">=</span><span class="str">"desc"</span><span class="pun">&gt;{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">description</span><span class="pun">}&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">article</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>我们在这个组件中引入了一个名为 Preview.css 样式文件。顾名思义，这是 Preview 组件依赖的样式文件。但 JavaScript 中怎么能引入 CSS 呢？实际上，其实这是 webpack 的一个插件 css-loader 所做的。css-loader 会识别到所有引入 CSS 的语句，并解析出对应的 CSS 文件地址，以 <code>&lt;style&gt;</code> 标签的形式动态插入到 DOM 节点中。</p>
<p>接下来的内容会稍显复杂。首先看看 PreviewList.js：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Preview</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./Preview'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">PreviewList</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    articleList</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">arrayOf</span><span class="pun">(</span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">object</span><span class="pun">)</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">articleList</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">item </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Preview</span><span class="pln"> </span><span class="pun">{...</span><span class="pln">item</span><span class="pun">}</span><span class="pln"> key</span><span class="pun">={</span><span class="pln">item</span><span class="pun">.</span><span class="pln">id</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>可以看出，PreviewList 也是一个无状态组件，它引入了 Preview 组件，并将传入的 <code>articleList</code> 遍历渲染出若干个对应的 Preview 组件。</p>
<p>PreviewList 本身并没有什么特别难以理解的地方，但是和它名字很相似的PreviewList- Redux.js 则是本节内容的关键。在介绍 Redux 应用目录结构时，我们提到过，*Redux.js 里包含了 *.js 这个组件需要的 reducer、action creator 和 constants。</p>
<p>现在让我们揭开它们的神秘面纱：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">const</span><span class="pln"> initialState </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  loading</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
  error</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
  articleList</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[],</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> LOAD_ARTICLES </span><span class="pun">=</span><span class="pln"> </span><span class="str">'LOAD_ARTICLES'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> LOAD_ARTICLES_SUCCESS </span><span class="pun">=</span><span class="pln"> </span><span class="str">'LOAD_ARTICLES_SUCCESS'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> LOAD_ARTICLES_ERROR </span><span class="pun">=</span><span class="pln"> </span><span class="str">'LOAD_ARTICLES_ERROR'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> loadArticles</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    types</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="pln">LOAD_ARTICLES</span><span class="pun">,</span><span class="pln"> LOAD_ARTICLES_SUCCESS</span><span class="pun">,</span><span class="pln"> LOAD_ARTICLES_ERROR</span><span class="pun">],</span><span class="pln">
    url</span><span class="pun">:</span><span class="pln"> </span><span class="str">'/api/articles.json'</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> previewList</span><span class="pun">(</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> initialState</span><span class="pun">,</span><span class="pln"> action</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">action</span><span class="pun">.</span><span class="pln">type</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">case</span><span class="pln"> LOAD_ARTICLES</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="pun">...</span><span class="pln">state</span><span class="pun">,</span><span class="pln">
        loading</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
        error</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">};</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">case</span><span class="pln"> LOAD_ARTICLES_SUCCESS</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="pun">...</span><span class="pln">state</span><span class="pun">,</span><span class="pln">
        loading</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
        error</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
        articleList</span><span class="pun">:</span><span class="pln"> action</span><span class="pun">.</span><span class="pln">payload</span><span class="pun">.</span><span class="pln">articleList</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">};</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">case</span><span class="pln"> LOAD_ARTICLES_ERROR</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="pun">...</span><span class="pln">state</span><span class="pun">,</span><span class="pln">
        loading</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
        error</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">};</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">default</span><span class="pun">:</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> state</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> previewList</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>这是实例中截至目前为止最复杂的文件，下面让我们分 3 部分来理解它。</p>
<p>首先，它定义了 <code>initialState</code>。可以看到，它在文件末尾的 <code>previewList</code> 函数（目前我们暂且叫它函数）中作为第一个参数 <code>state</code> 的默认值。也就是说，当传入的 state 为空时，state 将使用 <code>initialState</code> 的值。</p>
<p>定义 <code>initialState</code> 是为了 Redux 初始化并确定每个 reducer 的结构。而当初始化完成后，每次响应 action 时，reducer 将获得上一次计算出的 state 作为参数，这时 <code>initialState</code> 将不再发挥作用。</p>
<p>接下来的 3 个常量定义和一个函数定义在逻辑上属于一个整体，但是分别有不同的意义。<code>LOAD_ARTICLES</code> 等 3 个常量就是我们说的 <code>constants</code>，也就是一个 action 中的 <code>type</code> 字段，它们用来标识 Redux 应用中一个独立的 action。</p>
<p>而 <code>loadArticles()</code> 就是一个 action creator。因为每次调用 <code>loadArticles()</code> 函数时，它都会返回一个 action，所以 action creator 之名恰如其分。</p>
<p>至于这个 action creator 返回的 action，我们已经在 5.2 节里提到过，它是由 redux-composable-fetch 这个 middleware 所定义的格式。</p>
<p>在 PreviewListRedux.js 的最后，则是我们定义的 reducer。可以看到，我们的 reducer 会响应
3种类型的 action——<code>LOAD_ARTICLES</code>、<code>LOAD_ARTICLES_SUCCESS</code> 和 <code>LOAD_ARTICLES_ERROR</code>，这也是我们在之前刚刚定义的 action creator 可能会触发的 action 类型。</p>
<p>看到这里，我们应该大概明白了一个 *Redux.js 文件所包含的内容与各自的职责。接下来，我们继续看看它们是怎么在整个 Redux 应用中发挥作用的。</p>
<h3><strong>5.6.8　连接 Redux</strong></h3>
<p>在 5.6.7 节中，我们终于见识了 reducer 和 action creator 的真面目，而在这一节中，我们将学习怎么将这些 reducer 和 action creator 整合起来，最终变成应用中的一部分。</p>
<p>在 5.5 节中，我们详解了两类组件——容器型组件和展示型组件，这两类组件最直观的区别在于是否感知 Redux 的存在，或者说，是否使用 <code>connect</code> 方法让组件从 Redux 的状态树中获取数据。</p>
<p><strong>1. 让容器型组件关联数据</strong></p>
<p>我们现在已经熟悉了views/文件夹和components/文件夹的职责区别。很显然，views/ HomeRedux.js 包含了 Home 页面所有组件相关的 reducer 及 <code>actionCreator</code>：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> combineReducers </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux'</span><span class="pun">;</span><span class="pln">

</span><span class="com">// 引入 reducer 及 actionCreator</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> list </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../components/Home/PreviewListRedux'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> combineReducers</span><span class="pun">({</span><span class="pln">
  list</span><span class="pun">,</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">as</span><span class="pln"> listAction </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../components/Home/PreviewListRedux'</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>可以看到，views/ 目录下的 *Redux.js 文件在更大程度上只是起到一个整合分发的作用。和 components/ 目录下的 *Redux.js 文件一样，它默认导出的是当前路由需要的所有 reducer 的集合。这里我们引入了 Redux 官方提供的 <code>combineReducers</code> 方法，通过这个方法，我们可以方便地将多个 reducer 合并为一个。</p>
<p>此外，HomeRedux.js 还将 PreviewListRedux.js 中所有导出的对象合并后，导出一个 <code>listAction</code> 对象。稍后，就会看到我们为什么要这么组织文件。</p>
<p>先对 views/Home.js 做一些修改，让它与 Redux 进行第一次亲密接触：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> bindActionCreators </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> connect </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">PreviewList</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../components/Home/PreviewList'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> listActions </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./HomeRedux'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Home</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="str">&lt;h1&gt;</span><span class="typ">Home</span><span class="pun">&lt;/</span><span class="pln">h1</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">PreviewList</span><span class="pln">
          </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">list</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">listActions</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> connect</span><span class="pun">(</span><span class="pln">state </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    list</span><span class="pun">:</span><span class="pln"> state</span><span class="pun">.</span><span class="pln">home</span><span class="pun">.</span><span class="pln">list</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">},</span><span class="pln"> dispatch </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    listActions</span><span class="pun">:</span><span class="pln"> bindActionCreators</span><span class="pun">(</span><span class="pln">listActions</span><span class="pun">,</span><span class="pln"> dispatch</span><span class="pun">),</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">})(</span><span class="typ">Home</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>这里我们引入了 Redux 提供的工具方法 <code>bindActionCreators</code>、 react-redux 提供的 <code>connect</code> 方法以及在 components/Home/ 下的 PreviewList 组件。</p>
<p>另一个值得关注的修改点是，我们不再默认导出一个 React 组件，而是导出了将 Home 组件传入 <code>connect</code> 函数调用的结果后最终生成的组件。</p>
<p>事实上，调用 <code>connect</code> 函数返回了一个高阶组件生成器，而这个生成器会基于原始组件生成一个全新的组件，并给这个组件添加额外的 props。</p>
<p>在构造一个高阶组件生成器时，<code>connect</code> 最多接受 4 个参数，分别如下。</p>
<ul>
<li><p><strong><code>[mapStateToProps(state, [ownProps]): stateProps]</code></strong>（<strong>类型：函数</strong>）：接受完整的 Redux 状态树作为参数，返回当前组件相关部分的状态树，返回对象的所有 key 都会成为组件的 props。</p>
</li>
<li><p><strong><code>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps]</code></strong>（<strong>类型：对象或函数</strong>）：接受 Redux 的 <code>dispatch</code> 方法作为参数，返回当前组件相关部分的 action creator，并可以在这里将 action creator 与 dispatch 绑定，减少冗余代码。</p>
</li>
<li><p><strong><code>[mergeProps(stateProps, dispatchProps, ownProps): props]</code></strong>（<strong>类型：函数</strong>）：如果指定这个函数，你将分别获得 <code>mapStateToProps</code>、<code>mapDispatchToProps</code> 返回值以及当前组件的 props 作为参数，最终返回你期望的、完整的 props。</p>
</li>
<li><p><strong><code>[options]</code></strong>（<strong>类型：对象</strong>）：可选的额外配置项，有以下两项。</p>
<ul>
<li><p><strong><code>[pure = true]</code></strong>（<strong>类型：布尔</strong>）：该值设为 <code>true</code> 时，将为组件添加 <code>shouldComponentUpdate()</code> 生命周期函数，并对 <code>mergeProps</code> 方法返回的 props 进行浅层对比。</p>
</li>
<li><p><strong><code>[withRef = false]</code></strong>（<strong>类型：布尔</strong>）：若设为 <code>true</code>，则为组件添加一个 <code>ref</code> 值，后续可以使用 <code>getWrappedInstance()</code> 方法来获取该 <code>ref</code>，默认为 <code>false</code>。</p>
</li>
</ul>
</li>
</ul>
<p>关于 <code>connect</code> 函数的更多用法及背后的原理，请参考 6.5 节。</p>
<p>在我们的例子中，我们暂时只关心前两个参数，即 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code>。</p>
<p>在 <code>mapStateToProps</code> 中，我们从整棵 Redux 状态树中选取了 <code>state.home.list</code> 分支作为当前组件的 props，并将其命名为 list。这样，在 Home 组件中，就可以使用 <code>this.props.list</code> 来获取到所有 <code>PreviewListRedux</code> 中定义的状态。</p>
<p>而在 <code>mapDispatchToProps</code> 中，我们从前面提到的 HomeRedux.js 中引入了 <code>listActions</code>，并使用 Redux 提供的工具函数将 <code>listActions</code> 中的每一个 action creator（目前只有一个）与 dispatch 进行绑定，最终我们可以在 Home 组件中使用 <code>this.props.listActions</code> 来获取到绑定之后的 action creator。</p>
<p>最后，需要特别说明的是 Home 组件的 <code>render</code> 方法。我们将在 <code>connect</code> 中对生成的 <code>this.props. list</code> 和 <code>this.props.listActions</code> 分别进行解构，然后传给 PreviewList 组件作为 props。</p>
<p><strong>2. 让展示型组件使用数据</strong></p>
<p>相比于容器型组件与 Redux 的复杂交互，展示型组件实现起来则简单得多，毕竟一切需要的东西都已经通过 props 传进来了：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Preview</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./Preview'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">PreviewList</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    loading</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">bool</span><span class="pun">,</span><span class="pln">
    error</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">bool</span><span class="pun">,</span><span class="pln">
    articleList</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">arrayOf</span><span class="pun">(</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">object</span><span class="pun">),</span><span class="pln">
    loadArticles</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">func</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">loadArticles</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> loading</span><span class="pun">,</span><span class="pln"> error</span><span class="pun">,</span><span class="pln"> articleList </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">error</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">p className</span><span class="pun">=</span><span class="str">"message"</span><span class="pun">&gt;</span><span class="typ">Oops</span><span class="pun">,</span><span class="pln"> something </span><span class="kwd">is</span><span class="pln"> wrong</span><span class="pun">.&lt;/</span><span class="pln">p</span><span class="pun">&gt;;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">loading</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">p className</span><span class="pun">=</span><span class="str">"message"</span><span class="pun">&gt;</span><span class="typ">Loading</span><span class="pun">...&lt;/</span><span class="pln">p</span><span class="pun">&gt;;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> articleList</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">item </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(&lt;</span><span class="typ">Preview</span><span class="pln"> </span><span class="pun">{...</span><span class="pln">item</span><span class="pun">}</span><span class="pln"> key</span><span class="pun">={</span><span class="pln">item</span><span class="pun">.</span><span class="pln">id</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>首先，我们扩充了原本定义的 <code>propTypes</code>，新增了 <code>loading</code>、<code>error</code> 以及 <code>loadArticles</code> 的定义。</p>
<p>其次，我们添加了 <code>componentDidMount</code> 生命周期方法。在 PreviewList 组件加载完成后，我们调用了 <code>this.props.loadArticles()</code> 来加载文章列表。</p>
<p>最后，我们在 <code>render</code> 方法中针对不同的状态渲染出了友好的提示信息。</p>
<p>注意，在 PreviewList 组件中，所有的数据都来自 <code>this.props</code>。展示型组件自身不维护任何状态，也不知道 Redux 的存在。</p>
<p><strong>3. 注入 Redux</strong></p>
<p>在“让容器型组件关联数据 ”一节中，我们学习了如何使用 <code>connect</code> 方法关联 Redux 状态树中的部分状态。问题是，完整的 Redux 状态树是哪里来的呢？这一节将解答你的疑惑。</p>
<p>按照我们的目录约定，所有与 Redux 自身配置相关的代码都放在 src/redux/ 文件夹下，下面让我们来初始化这些文件：</p>
<p>src/<br>├── app.js<br>├── components<br>├── layouts<br>├── redux<br>│　　├── configureStore.js<br>│　　└── reducers.js<br>├── routes<br>└── views</p>
<p>先来看看 reducers.js，这个文件里汇总了整个应用所有的 reducer，而汇总的方法则十分简单。因为我们在 views/ 文件夹中已经对各个路由需要的 reducer 做过一次整理聚合，所以在 reducers.js 中直接引用 views/*Redux.js 中默认导出的 reducer 即可。</p>
<p>而 configureStore.js 则是生成 Redux store 的关键文件，其中将看到 5.1 节中提到的 Redux 的核心 API——<code>createStore</code> 方法：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> createStore</span><span class="pun">,</span><span class="pln"> combineReducers</span><span class="pun">,</span><span class="pln"> compose</span><span class="pun">,</span><span class="pln"> applyMiddleware </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> routerReducer </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">ThunkMiddleware</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux-thunk'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> rootReducer </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./reducers'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> finalCreateStore </span><span class="pun">=</span><span class="pln"> compose</span><span class="pun">(</span><span class="pln">
  applyMiddleware</span><span class="pun">(</span><span class="typ">ThunkMiddleware</span><span class="pun">)</span><span class="pln">
</span><span class="pun">)(</span><span class="pln">createStore</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> reducer </span><span class="pun">=</span><span class="pln"> combineReducers</span><span class="pun">(</span><span class="typ">Object</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">({},</span><span class="pln"> rootReducer</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  routing</span><span class="pun">:</span><span class="pln"> routerReducer</span><span class="pun">,</span><span class="pln">
</span><span class="pun">}));</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> configureStore</span><span class="pun">(</span><span class="pln">initialState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> store </span><span class="pun">=</span><span class="pln"> finalCreateStore</span><span class="pun">(</span><span class="pln">reducer</span><span class="pun">,</span><span class="pln"> initialState</span><span class="pun">);</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> store</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在 configureStore.js 中，并没有直接使用 Redux 提供的原始 <code>createStore</code> 方法来创建 store，而是利用 <code>compose</code> 方法对 <code>createStore</code> 方法进行了增强，并生成了新的 <code>createStore</code> 方法—— <code>finalCreateStore</code>。</p>
<p><code>applyMiddleware</code> 是 Redux 提供的另一个 API，也是 Redux 具有高度可扩展性的重要保障。使用 middleware，可以让 Redux 解析各种类型的 action。除了最原始的对象外，我们的 action 还可以是方法、 promise，以及任何你能想象的类型。</p>
<p>此外，我们还在初始化 Store 时引入了 react-router-redux 提供的 routerReducer，这个 reducer 帮助我们实现了路由状态与 Redux store 的统一。</p>
<p>在完成 store 的配置后，我们需要在某个地方新建一个实例，即 app.js：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> configureStore </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./redux/configureStore'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Provider</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> syncHistoryWithStore </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> hashHistory </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> routes </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./routes'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> store </span><span class="pun">=</span><span class="pln"> configureStore</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> history </span><span class="pun">=</span><span class="pln"> syncHistoryWithStore</span><span class="pun">(</span><span class="pln">hashHistory</span><span class="pun">,</span><span class="pln"> store</span><span class="pun">);</span><span class="pln">

</span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">render</span><span class="pun">((</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="typ">Provider</span><span class="pln"> store</span><span class="pun">={</span><span class="pln">store</span><span class="pun">}&gt;</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">routes</span><span class="pun">(</span><span class="pln">history</span><span class="pun">)}</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="typ">Provider</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">),</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="str">'root'</span><span class="pun">));</span><span class="pln">
</span></code></pre>
<p>首先，我们引入了刚刚定义的 <code>configureStore</code> 方法。接着，引入 Redux 提供的 Provider 组件，它将成为整个 Redux 应用的根组件。</p>
<p>接下来的两个依赖是为了完善我们的路由系统。我们将原本在 src/routes/index.js 中引入的 React Router 中的 <code>hashHistory</code> 改为在 app.js 中引入，因为 react-router-redux 需要对这个 <code>history</code> 对象进行强化，以此保证 React Router 与 Redux store 的一致和统一。</p>
<p>做了这么多改动，是时候看看效果了，如图 5-9 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.009.png" alt="{%}"></p>
<p><strong>图 5-9　应用界面</strong></p>
<p>虽然界面看起来只是多了一个 Loading 状态，但实际上我们已经完成了 Redux 应用绝大部分功能的连线搭桥，剩下的只是丰富样式和业务逻辑。</p>
<h3><strong>5.6.9　引入 Redux Devtools</strong></h3>
<p>在丰富业务逻辑之前，我们有必要先在项目中引入 Redux 应用的大杀器——Redux Devtools。在 Redux 中，所有的数据变化都来源一个个的 action，因此，如果有一个工具能方便我们查看 action 的触发记录以及数据的更改情况，我们就可以非常方便地对应用进行调试。好消息是，Redux 本身就提供了这样强大的功能。</p>
<p>由于 Devtools 并没有打包到 Redux 包中，我们需要单独下载这些依赖：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">$ npm install </span><span class="pun">--</span><span class="pln">save</span><span class="pun">-</span><span class="pln">dev redux</span><span class="pun">-</span><span class="pln">devtools redux</span><span class="pun">-</span><span class="pln">devtools</span><span class="pun">-</span><span class="pln">log</span><span class="pun">-</span><span class="pln">monitor redux</span><span class="pun">-</span><span class="pln">devtools</span><span class="pun">-</span><span class="pln">dock</span><span class="pun">-</span><span class="pln">monitor
</span></code></pre>
<p>这里我们不仅下载了 redux-devtools，同时还下载了 redux-devtools-log-monitor 和 redux-devtools-dock-monitor，后面两个其实是 React 组件。Redux 作者在设计 Devtools 时，特意将模块进行了清晰的划分，这样你可以根据自己的需要选择合适的 monitor。</p>
<p>现在将 DevTools 初始化的相关代码统一放在 src/redux/DevTools.js 中：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> createDevTools </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux-devtools'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">LogMonitor</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux-devtools-log-monitor'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">DockMonitor</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux-devtools-dock-monitor'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">DevTools</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> createDevTools</span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="typ">DockMonitor</span><span class="pln"> toggleVisibilityKey</span><span class="pun">=</span><span class="str">'ctrl-h'</span><span class="pln">
               changePositionKey</span><span class="pun">=</span><span class="str">'ctrl-q'</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">LogMonitor</span><span class="pln"> theme</span><span class="pun">=</span><span class="str">'tomorrow'</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="typ">DockMonitor</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="typ">DevTools</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>DockMonitor 决定了 DevTools 在屏幕上显示的位置，我们可以按 Control+Q 键切换位置，或者按 Control+H 键隐藏 DevTool。而 LogMonitor 决定了 DevTools 中显示的内容，默认包含了 action 的类型、完整的 action 参数以及 action 处理完成后新的 state。效果如图 5-10 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.010.png" alt="{%}"></p>
<p><strong>图 5-10　Redux DevTools</strong></p>
<p>引入 Redux DevTools 后，极大地简化了我们对于整个应用状态的推导工作。因为我们能看到每次 action 的完整信息，以及 action 处理之后的 state，而这些 state 又被 connect 后用于 React 组件的渲染，最终呈现在用户界面上。</p>
<h3><strong>5.6.10　利用 middleware 实现 Ajax 请求发送</strong></h3>
<p>事实上，当在浏览器中预览我们的 Redux 应用时，你会发现这样一个错误信息：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="typ">Uncaught</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Actions</span><span class="pln"> may </span><span class="kwd">not</span><span class="pln"> have an </span><span class="kwd">undefined</span><span class="pln"> </span><span class="str">"type"</span><span class="pln"> </span><span class="kwd">property</span><span class="pun">.</span><span class="pln"> </span><span class="typ">Have</span><span class="pln"> you misspelled a constant</span><span class="pun">?</span><span class="pln">
</span></code></pre>
<p>这是因为 Redux 没有正确识别我们在 views/Home/PreviewListRedux.js 中定义的 <code>loadArticles()</code>方法返回的 action。</p>
<p>在 5.2 节中，我们已经介绍了如何使用 redux-composable-fetch 这个 middleware 实现异步请求，现在只需要引入这个 middleware 并把它传给 store 增强器即可。</p>
<p>让我们回顾一下 <code>configureStore</code> 的实现：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> createStore</span><span class="pun">,</span><span class="pln"> combineReducers</span><span class="pun">,</span><span class="pln"> compose</span><span class="pun">,</span><span class="pln"> applyMiddleware </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> routerReducer </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">ThunkMiddleware</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux-thunk'</span><span class="pun">;</span><span class="pln">
</span><span class="com">// 引入请求 middleware 的工厂方法</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> createFetchMiddleware </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux-composable-fetch'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> rootReducer </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./reducers'</span><span class="pun">;</span><span class="pln">

</span><span class="com">// 创建一个请求 middleware 的示例</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">FetchMiddleware</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> createFetchMiddleware</span><span class="pun">();</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> finalCreateStore </span><span class="pun">=</span><span class="pln"> compose</span><span class="pun">(</span><span class="pln">
  applyMiddleware</span><span class="pun">(</span><span class="pln">
    </span><span class="typ">ThunkMiddleware</span><span class="pun">,</span><span class="pln">
    </span><span class="com">// 将请求 middleware 注入 store 增强器中</span><span class="pln">
    </span><span class="typ">FetchMiddleware</span><span class="pln">
  </span><span class="pun">)</span><span class="pln">
</span><span class="pun">)(</span><span class="pln">createStore</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> reducer </span><span class="pun">=</span><span class="pln"> combineReducers</span><span class="pun">(</span><span class="typ">Object</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">({},</span><span class="pln"> rootReducer</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  routing</span><span class="pun">:</span><span class="pln"> routerReducer</span><span class="pun">,</span><span class="pln">
</span><span class="pun">}));</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> configureStore</span><span class="pun">(</span><span class="pln">initialState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> store </span><span class="pun">=</span><span class="pln"> finalCreateStore</span><span class="pun">(</span><span class="pln">reducer</span><span class="pun">,</span><span class="pln"> initialState</span><span class="pun">);</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> store</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这样，我们的应用就能正确识别任何异步请求的 action 了。</p>
<h3><strong>5.6.11　请求本地的数据</strong></h3>
<p>由于我们的博客系统需要通过异步请求获取数据，而为了减少不必要的干扰，我们并不会具体实现一个服务端程序来响应这些数据。因此，一个可行的方式是在本地模拟这些结果。</p>
<p>前面说到，我们可以利用 webpack-dev-server 在本地启动一个简单的 http 服务器来响应页面，这里同样可以利用这一特性伪造一些本地数据：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pln">src</span><span class="pun">/</span><span class="pln">
api</span><span class="pun">/</span><span class="pln">
  articles</span><span class="pun">.</span><span class="pln">json  </span><span class="pun">文章列表</span><span class="pln">
  article</span><span class="pun">/</span><span class="pln">
    </span><span class="lit">1.json</span><span class="pln">       id </span><span class="pun">为</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">的文章信息，以此类推</span><span class="pln">
    </span><span class="lit">2.json</span><span class="pln">
    </span><span class="lit">3.json</span><span class="pln">
</span></code></pre>
<p>这样我们在访问 http://127.0.0.1:8080/api/articles.json 时，其实访问的是我们在本地定义的 JSON 文件，而不是远程服务器的接口。这个技巧在本地开发前端代码时会经常用到。</p>
<blockquote>
<p><strong>说明</strong>　如果你不能通过上述链接正常访问到存储在本地的 JSON 文件，请确保执行 <code>webpack-dev- server</code> 命令时添加了 <code>--content-base .</code> 参数。</p>
</blockquote>
<p>我们在 articles.json 中模拟了如下的数据结构：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="pun">{</span><span class="pln">
  </span><span class="pun">[</span><span class="pln">
    </span><span class="str">"id"</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln">
    </span><span class="str">"title"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"Angular2 中那些我看不懂的地方"</span><span class="pun">,</span><span class="pln">
    </span><span class="str">"description"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"博客停更了近 3 个月，实在是愧对很多在微博上推荐的同学。因为最近大部分时间都投入
     在公司里一个比较复杂的项目中，直到本周才算正式发布，稍得解脱。说这个项目复杂，不仅是因为需求设
     计复杂，更是因为在这个[...]"</span><span class="pun">,</span><span class="pln">
    </span><span class="str">"date"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"2016-04-17"</span><span class="pln">
  </span><span class="pun">],</span><span class="pln">
  </span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>看看自动刷新的浏览器里面，一个博客的雏形是否已经展示出来了？如图 5-11 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.011.png" alt="{%}"></p>
<p><strong>图 5-11　应用界面</strong></p>
<h3><strong>5.6.12　页面之间的跳转</strong></h3>
<p>现在博客的首页已经初见效果，下一步就是要实现文章详情页了。首先要考虑的问题是，用户怎么进入文章详情页？当然是点击链接。</p>
<p>前面讲到 Nav.js 时，已经领略了使用 React Router 提供了 <code>&lt;Link&gt;</code> 组件模拟链接的做法，但是在 Redux 应用中，路由状态也属于整个应用状态的一部分，所以更合理的方案应该是通过分发 action 来更新路由。</p>
<p>在这一节中，我们会讲述怎样实现通过分发 action 的方法完成 Redux 应用的路由更新。</p>
<p>由于 React Router 本身是一个独立的路由处理库，要想把 React Router 中维持的状态暴露给 Redux 应用，或是在 Redux 应用中修改 React Router 的状态，我们需要某种手段将这二者结合起来，这就要说到 react-router-redux 中提供的 <code>routerMiddleware</code> 了：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="com">// redux/configureStore.js</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> hashHistory </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> routerMiddleware </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">import</span><span class="pln"> rootReducer </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./reducers'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> finalCreateStore </span><span class="pun">=</span><span class="pln"> compose</span><span class="pun">(</span><span class="pln">
  applyMiddleware</span><span class="pun">(</span><span class="pln">
    </span><span class="com">// 引入其他 middleware</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
    </span><span class="com">// 引入 react-router-redux 提供的 middleware</span><span class="pln">
    routerMiddleware</span><span class="pun">(</span><span class="pln">hashHistory</span><span class="pun">)</span><span class="pln">
  </span><span class="pun">)</span><span class="pln">
</span><span class="pun">)(</span><span class="pln">createStore</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>引入了新的 middleware 之后，就可以像下面这样简单修改当前路由了：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> push </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pun">;</span><span class="pln">

</span><span class="com">// 在任何可以拿到 store.dispatch 方法的环境中</span><span class="pln">
store</span><span class="pun">.</span><span class="pln">dispatch</span><span class="pun">(</span><span class="pln">push</span><span class="pun">(</span><span class="str">'/'</span><span class="pun">));</span><span class="pln">
</span></code></pre>
<p>既然做好了准备工作，让我们对文章列表页组件进行小小的修改，以便完成路由跳转：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="com">// components/Home/Preview.js</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Preview</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    title</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    link</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    push</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">func</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  handleNavigate</span><span class="pun">(</span><span class="pln">id</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 阻止原生链接跳转</span><span class="pln">
    e</span><span class="pun">.</span><span class="pln">preventDefault</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// 使用 react-router-redux 提供的方法跳转，以便更新对应的 store</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">push</span><span class="pun">(</span><span class="pln">id</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">article className</span><span class="pun">=</span><span class="str">"article-preview-item"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">h1 className</span><span class="pun">=</span><span class="str">"title"</span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="pln">a href</span><span class="pun">={</span><span class="str">`/detail/${this.props.id}`</span><span class="pun">}</span><span class="pln"> onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleNavigate</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln">
            </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)}&gt;</span><span class="pln">
            </span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">title</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">&lt;/</span><span class="pln">a</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;/</span><span class="pln">h1</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">span className</span><span class="pun">=</span><span class="str">"date"</span><span class="pun">&gt;{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">date</span><span class="pun">}&lt;/</span><span class="pln">span</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">p className</span><span class="pun">=</span><span class="str">"desc"</span><span class="pun">&gt;{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">description</span><span class="pun">}&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">article</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>显而易见的变化是，我们在原本的标题中添加了链接，并指定了点击链接时由 <code>handleNavigate</code>方法来响应。在 <code>handleNavigate</code> 方法中，首先执行 <code>e.preventDefault()</code> 来阻止原始的链接跳转，然后调用了一个之前并不存在的 <code>this.props.push</code> 方法，它就是用来处理路由的更新的。</p>
<p>由于 PreviewList 本身是一个对 Redux 无感知的展示型组件，所以它并不能直接获取到 store 的引用，也就无法使用 <code>store.dispatch</code> 方法来随意分发 action。因此，我们需要给 PreviewList 传递一个绑定好 dispatch 的 <code>push</code> 方法，让它直接调用即可。那么，哪里可以直接拿到 <code>store.dispatch</code> 呢？很简单，所有使用 <code>connect</code> 方法的组件都可以感知 Redux：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="com">// views/Home.js</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> bindActionCreators </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> connect </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-redux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">PreviewList</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../components/Home/PreviewList'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> listActions </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./HomeRedux'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> push </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-router-redux'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Home</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="str">&lt;h1&gt;</span><span class="typ">Home</span><span class="pun">&lt;/</span><span class="pln">h1</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">PreviewList</span><span class="pln">
          </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">list</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">listActions</span><span class="pun">}</span><span class="pln">
          push</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">push</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> connect</span><span class="pun">(</span><span class="pln">state </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    list</span><span class="pun">:</span><span class="pln"> state</span><span class="pun">.</span><span class="pln">home</span><span class="pun">.</span><span class="pln">list</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">},</span><span class="pln"> dispatch </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    listActions</span><span class="pun">:</span><span class="pln"> bindActionCreators</span><span class="pun">(</span><span class="pln">listActions</span><span class="pun">,</span><span class="pln"> dispatch</span><span class="pun">),</span><span class="pln">
    push</span><span class="pun">:</span><span class="pln"> bindActionCreators</span><span class="pun">(</span><span class="pln">push</span><span class="pun">,</span><span class="pln"> dispatch</span><span class="pun">),</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">})(</span><span class="typ">Home</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>我们在 Home.js 中引入了 react-router-redux 提供的 <code>push</code> 方法，将其和 <code>store.dispatch</code> 绑定后，作为 props 传给了 PreviewList。因为在 PreviewList 里并没有任何直接修改路由的需要，所以 PreviewList 又将 <code>push</code> 传递给了 Preview。这样，我们在 Preview 里就可以通过 <code>this.props.push()</code> 来修改路由了。</p>
<p>现在点击其中一个链接，看看 Redux Devtools 中记录了怎样的 action，如图 5-12 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/07.d05z.012.png" alt="{%}"></p>
<p><strong>图 5-12　应用界面</strong></p>
<p>可以看到，在地址栏中我们的路由已经发生了改变，Redux Devtools 也为我们记录下了这次 action。但是，界面看起来不太正常吧？那是因为我们还没有在 Detail 组件中写任何逻辑。</p>
<p>当我们点击一篇博文的链接进入详情页时，应用应该根据当前路由中博文的 id 请求对应的详细数据。由于详情页中的逻辑与列表页并没有太大的差别，这里就不再给出详细的代码了。</p>
<h3><strong>5.6.13　优化与改进</strong></h3>
<p>Redux DevTools 虽然功能强大，但是这样的工具绝对不应该出现在生产环境中。因为它不仅增加了最终打包 JavaScript 文件的大小，更会很大程度地影响整个应用的性能。</p>
<p>所以，我们希望调整代码以及构建脚本，最终实现在开发环境中加载 Redux DevTools，而在生产环境中不进行任何加载。</p>
<p>要实现这样的需求，首先需要添加一款 webpack 的插件——DefinePlugin，这款插件允许我们定义任意的字符串，并将所有文件中包含这些字符串的地方都替换为指定值。</p>
<p>其次，我们需要了解一种常见的定义 Node.js 应用环境的方法——环境变量。一般意义上来说，我们习惯使用 <code>process.env.NODE_ENV</code> 这个变量的值来确定当前是在什么环境中运行应用。当读取不到该值时，默认当前是开发环境；而当 <code>process.env.NODE_ENV=production</code> 时，我们认为当前是生产环境。</p>
<p>掌握这两点知识后，只需要在代码中添加合适的判断语句，最终 webpack 会根据不同的环境帮我们将判断语句中的条件换为可以直接求值的表达式。而在生产环境中，配合另一款插件 UglifyJS 的无用代码移除功能，可以方便地将任何不必要的依赖统统移除。比如，下面的代码在开发环境是这样的：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">process</span><span class="pun">.</span><span class="pln">env</span><span class="pun">.</span><span class="pln">NODE_ENV </span><span class="pun">===</span><span class="pln"> </span><span class="str">'production'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 这里的代码只会在生成环境执行</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 这里的代码只会在开发环境执行</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">当在生产环境构建时，代码将先被转化为：</span><span class="pln">

</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">true</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 这里的代码只会在生成环境执行</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 这里的代码只会在开发环境执行</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>并最终进一步转化为：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="com">// 这里的代码只会在生成环境执行</span><span class="pln">
</span></code></pre>
<p>这样既保证了不同环境加载不同代码的灵活性，又保证了在生产环境打包时最小程度地引入依赖。</p>
<h3><strong>5.6.14　添加单元测试</strong></h3>
<p>在上一章中，我们学习了如何使用 Jest 测试 Flux 中的 store。虽然借助 Jest 强大的 mock 功能可以实现我们的最终目的，但是那些技巧确实会让新手们感觉有点摸不着头脑。</p>
<p>这种疑惑在我们测试 Redux 中的 reducer 时将不复存在，因为 reducer 就是最常见也是最纯洁的函数。</p>
<p>因此，我们将不需要任何额外的模拟或设置，只需要选择自己喜欢的测试运行框架和断言库，直接完成测试用例并执行即可。</p>
<p>这里以测试 <code>previewList</code> 这个 reducer 为例，让我们看看具体的测试代码该如何编写：</p>
<pre class="代码无行号 prettyprint prettyprinted"><code><span class="kwd">import</span><span class="pln"> previewList</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> LOAD_ARTICLES_SUCCESS </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../src/components/Home/PreviewListRedux'</span><span class="pun">;</span><span class="pln">

describe</span><span class="pun">(</span><span class="str">'Preview List Reducer'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  it</span><span class="pun">(</span><span class="str">'should propagate new articles when loaded'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> data </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[{</span><span class="pln">id</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> title</span><span class="pun">:</span><span class="pln"> </span><span class="str">'test'</span><span class="pun">}];</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> previewList</span><span class="pun">({</span><span class="pln">
      type</span><span class="pun">:</span><span class="pln"> LOAD_ARTICLES_SUCCESS</span><span class="pun">,</span><span class="pln">
      payload</span><span class="pun">:</span><span class="pln"> data</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">

    expect</span><span class="pun">(</span><span class="pln">result</span><span class="pun">.</span><span class="pln">articleList</span><span class="pun">).</span><span class="pln">to</span><span class="pun">.</span><span class="pln">deep</span><span class="pun">.</span><span class="pln">equal</span><span class="pun">(</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>更有意思的是，借助 Redux 神奇的 Devtools 以及其优秀的扩展能力，在开源社区中出现了一个可以“帮助我们写测试”的 Redux Devtools——<code>redux-test-recorder</code>。在开启这个 Devtools 之后，我们只需要按照页面的交互方式操作一遍应用，就能自动生成 reducer 的单元测试代码。</p>
<p>到这里，Redux 应用的核心概念我们已经熟悉得差不多了。接下来，暂时忘掉 Redux 的 API、酷炫的 DevTools，思考一下我们为什么需要 Redux？</p>
<h2><strong>5.7　小结</strong></h2>
<p>在本章中，我们详细介绍了 Redux 应用架构。从 SPA 应用的角度讲述了如何构建一个 Redux React 应用，并对 Redux、React Redux、Redux middleware 作了源码解读，希望读者有一个较深层次的理解。</p>
<p>千里之行，始于足下，Redux 应用架构的出现还是为了能够在生产环境中解决更加复杂的业务问题。在下一章中，我们将着重阐述 Redux 在复杂应用中是如何发挥作用的。</p>

                        </div>
                    </div>
                </div>