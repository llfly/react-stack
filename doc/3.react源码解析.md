<div class="markdown-body">
            <h1><strong>第 3 章　解读 React 源码</strong></h1>
<p>通过前面两章，我们系统学习了 React 的基本概念、API、组件的构建方法以及高级用法，然而这背后的一切显得那么神奇而又神秘，它们到底是怎么运转的呢？</p>
<p>本章会通过分析 React 15.0 的源码，深入 Virtual DOM 内部的实现机制和原理，让我们一步步揭开 Virtual DOM 的神秘面纱，探索其内部的精彩世界！</p>
<h2><strong>3.1　初探 React 源码</strong></h2>
<p>在深入分析 React 源码之前，我们先大致了解一下 React 源码的组织结构，如图 3-1 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.001.png" alt="" width="90%" style="width: 90%"></p>
<p><strong>图 3-1　React 源码目录</strong></p>
<p>在 React 源码中，每个文件的命名风格属于字面与含义可相互解释，整体的代码结构按照 addons、isomorphic、renderers、shared、core、test 进行组织。</p>
<ul>
<li><p><strong>addons</strong>：包含一系列的工具方法插件，如 <code>PureRenderMixin</code>、<code>CSSTransitionGroup</code>、<code>Fragment</code>、<code>LinkedStateMixin</code> 等。</p>
</li>
<li><p><strong>isomorphic</strong>：包含一系列同构方法。</p>
</li>
<li><p><strong>shared</strong>：包含一些公用或常用方法，如 <code>Transaction</code>、<code>CallbackQueue</code> 等。</p>
</li>
<li><p><strong>test</strong>：包含一些测试方法等。</p>
</li>
<li><p><strong>core/tests</strong>：包含一些边界错误的测试用例。</p>
</li>
<li><p><strong>renderers</strong>：是 React 代码的核心部分，它包含了大部分功能实现，此处对其进行单独分析。</p>
</li>
</ul>
<p>renderers 分为 dom 和 shared 目录。</p>
<ul>
<li><p><strong>dom</strong>：包含 client、server 和 shared。</p>
<ul>
<li><p><strong>client</strong>：包含 DOM 操作方法（如 <code>findDOMNode</code>、<code>setInnerHTML</code>、<code>setTextContent</code> 等）以及事件方法，结构如图 3-2 所示。这里的事件方法主要是一些非底层的实用性事件方法，如事件监听（<code>ReactEventListener</code>）、常用事件方法（<code>TapEventPlugin</code>、<code>EnterLeaveEventPlugin</code>）以及一些合成事件（<code>SyntheticEvents</code> 等）。</p>
<p><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.002.png" alt="{%}"></p>
<p><strong>图 3-2　React 下 renderers 源码目录</strong></p>
</li>
<li><p><strong>server</strong>：主要包含服务端渲染的实现和方法（如 <code>ReactServerRendering</code>、<code>ReactServerRenderingTransaction</code> 等）。</p>
</li>
<li><p><strong>shared</strong>：包含文本组件（ReactDOMTextComponent）、标签组件（ReactDOMComponent）、DOM 属性操作（<code>DOMProperty</code>、<code>DOMPropertyOperations</code>）、CSS 属性操作（<code>CSSProperty</code>、<code>CSSPropertyOperations</code>）等。</p>
</li>
</ul>
</li>
<li><p><strong>shared</strong>：包含 event 和 reconciler。</p>
<ul>
<li><p><strong>event</strong>：包含一些更为底层的事件方法，如事件插件中心（<code>EventPluginHub</code>）、事件注册（<code>EventPluginRegistry</code>）、事件传播（<code>EventPropagators</code>）以及一些事件通用方法。</p>
<p>React 自定义了一套通用事件的插件系统，该系统包含事件监听器、事件发射器、事件插件中心、点击事件、进/出事件、简单事件、合成事件以及一些事件方法，如图 3-3 所示。</p>
<p><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.003.png" alt="{%}"></p>
<p><strong>图 3-3　通用事件插件系统</strong></p>
</li>
<li><p><strong>reconciler</strong>：称为协调器，它是最为核心的部分，包含 React 中自定义组件的实现（ReactCompositeComponent）、组件生命周期机制、setState 机制（ReactUpdates、ReactUpdateQueue）、DOM diff 算法（ReactMultiChild）等重要的特性方法。</p>
</li>
</ul>
</li>
</ul>
<p>那么，为何说 reconciler 是 React 最为核心的部分呢？</p>
<p>在 Web 开发中，要将更新的数据实时反应到 UI 上，就不可避免地需要对 DOM 进行操作，而复杂频繁的 DOM 操作通常是产生性能瓶颈的原因之一。为此，React 引入了 Virtual DOM 机制。毫不夸张地说，Virtual DOM 是 React 的核心与精髓所在，而 reconciler 就是实现 Virtual DOM 的主要源码。</p>
<p>Virtual DOM 实际上是在浏览器端用 JavaScript 实现的一套 DOM API，它之于 React 就好似一个虚拟空间，包括一整套 Virtual DOM 模型、生命周期的维护和管理、性能高效的 diff 算法和将 Virtual DOM 展示为原生 DOM 的 Patch 方法等。</p>
<p>基于 React 进行开发时，所有的 DOM 树都是通过 Virtual DOM 构造的。React 在 Virtual DOM 上实现了 DOM diff 算法，当数据更新时，会通过 diff 寻找到需要变更的 DOM 节点，并只对变化的部分进行实际的浏览器的 DOM 更新，而不是重新渲染整个 DOM 树。</p>
<p>React 也能够实现 Virtual DOM 的批处理更新，当操作 Virtual DOM 时，不会马上生成真实的 DOM，而是会将一个事件循环（event loop）内的两次数据更新进行合并，这样就使得 React 能够在事件循环的结束之前完全不用操作真实的 DOM。例如，多次进行节点内容 A→B，B→A 的变化，React 会将多次数据更新合并为 A→B→A，即 A→A，认为数据并没有更新，因此 UI 也不会发生任何变化。如果通过手动控制，这种逻辑通常是极其复杂的。</p>
<p>尽管每一次都需要构造完整的 Virtual DOM 树，但由于 Virtual DOM 是 JavaScript 对象，性能极高，而对原生 DOM 进行操作的仅仅是 diff 部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到具体的 DOM 元素，而只需要关心在任意数据状态下，整个界面是如何渲染的。</p>
<p>那么，React 中是如何实现 Virtual DOM 机制的呢？为众人所津津乐道的 diff 算法到底有何神秘之处呢？组件的生命周期又是如何进行管理的呢？</p>
<p>从下一节开始，我们将通过分析 React 15.0 源码，深入研究 Virtual DOM 内部的实现机制及原理。</p>
<h2><strong>3.2　Virtual DOM 模型</strong></h2>
<p>Virtual DOM 之于 React，就好比一个虚拟空间，React 的所有工作几乎都是基于 Virtual DOM 完成的。其中，Virtual DOM 模型负责 Virtual DOM 底层框架的构建工作，它拥有一整套的 Virtual DOM 标签，并负责虚拟节点及其属性的构建、更新、删除等工作。那么，Virtual DOM 模型到底是如何构建虚拟节点，如何更新节点属性的呢？</p>
<p>其实，构建一套简易 Virtual DOM 模型并不复杂，它只需要具备一个 DOM 标签所需的基本元素即可：</p>
<ul>
<li><p>标签名</p>
</li>
<li><p>节点属性，包含样式、属性、事件等</p>
</li>
<li><p>子节点</p>
</li>
<li><p>标识 id</p>
</li>
</ul>
<p>示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">{</span><span class="pln">
  </span><span class="com">// 标签名</span><span class="pln">
  tagName</span><span class="pun">:</span><span class="pln"> </span><span class="str">'div'</span><span class="pun">,</span><span class="pln">
  </span><span class="com">// 属性</span><span class="pln">
  properties</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 样式</span><span class="pln">
    style</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{}</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
  </span><span class="com">// 子节点</span><span class="pln">
  children</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[],</span><span class="pln">
  </span><span class="com">// 唯一标识</span><span class="pln">
  key</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>Virtual DOM 模型当然不止于此，却也离不开这些基础元素。现在就让我们揭下它的神秘面纱，一探究竟吧！</p>
<p>Virtual DOM 中的节点称为 ReactNode，它分为3种类型 ReactElement、ReactFragment 和 ReactText。其中，ReactElement 又分为 ReactComponentElement 和 ReactDOMElement。</p>
<p>下面是 ReactNode 中不同类型节点所需要的基础元素：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">type </span><span class="typ">ReactNode</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactElement</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="typ">ReactFragment</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="typ">ReactText</span><span class="pun">;</span><span class="pln">
type </span><span class="typ">ReactElement</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactComponentElement</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="typ">ReactDOMElement</span><span class="pun">;</span><span class="pln">
type </span><span class="typ">ReactDOMElement</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  type </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
  props </span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    children </span><span class="pun">:</span><span class="pln"> </span><span class="typ">ReactNodeList</span><span class="pun">,</span><span class="pln">
    className </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    etc</span><span class="pun">.</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
  key </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> number </span><span class="pun">|</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
  </span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="kwd">null</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
type </span><span class="typ">ReactComponentElement</span><span class="pun">&lt;</span><span class="typ">TProps</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  type </span><span class="pun">:</span><span class="pln"> </span><span class="typ">ReactClass</span><span class="pun">&lt;</span><span class="typ">TProps</span><span class="pun">&gt;,</span><span class="pln">
  props </span><span class="pun">:</span><span class="pln"> </span><span class="typ">TProps</span><span class="pun">,</span><span class="pln">
  key </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> number </span><span class="pun">|</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
  </span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="kwd">null</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
type </span><span class="typ">ReactFragment</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">&lt;</span><span class="typ">ReactNode</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="typ">ReactEmpty</span><span class="pun">&gt;;</span><span class="pln">
type </span><span class="typ">ReactNodeList</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactNode</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="typ">ReactEmpty</span><span class="pun">;</span><span class="pln">
type </span><span class="typ">ReactText</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">string</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> number</span><span class="pun">;</span><span class="pln">
type </span><span class="typ">ReactEmpty</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>那么，Virtual DOM 模型是如何根据这些节点类型来创建元素的呢？</p>
<h3><strong>3.2.1　创建 React 元素</strong></h3>
<p>在 1.2 节里，我们介绍过 JSX 的语法，现在先来回顾下它的用法。下面是一段 JSX 与编译后的 JavaScript：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">Nav</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Profile</span><span class="pun">;</span><span class="pln">
</span><span class="com">// 输入（JSX）：</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> app </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Nav</span><span class="pln"> color</span><span class="pun">=</span><span class="str">"blue"</span><span class="pun">&gt;&lt;</span><span class="typ">Profile</span><span class="pun">&gt;</span><span class="pln">click</span><span class="pun">&lt;</span><span class="str">/Profile&gt;&lt;/</span><span class="typ">Nav</span><span class="pun">&gt;;</span><span class="pln">
</span><span class="com">// 输出（JavaScript）：</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> app </span><span class="pun">=</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="pln">
  </span><span class="typ">Nav</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">{</span><span class="pln">color</span><span class="pun">:</span><span class="str">"blue"</span><span class="pun">},</span><span class="pln">
  </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="typ">Profile</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="str">"click"</span><span class="pun">)</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>通过 JSX 创建的虚拟元素最终会被编译成调用 React 的 <code>createElement</code> 方法。那么 <code>createElement</code> 方法到底做了什么，它的奥秘是什么呢？我们来解读相关源码（源码路径：/v15.0.0/src/isomorphic/classic/element/ReactElement.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// createElement 只是做了简单的参数修正，返回一个 ReactElement 实例对象，</span><span class="pln">
</span><span class="com">// 也就是虚拟元素的实例</span><span class="pln">
</span><span class="typ">ReactElement</span><span class="pun">.</span><span class="pln">createElement </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">type</span><span class="pun">,</span><span class="pln"> config</span><span class="pun">,</span><span class="pln"> children</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 初始化参数</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> propName</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> props </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> key </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> </span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> </span><span class="kwd">self</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> source </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 如果存在 config，则提取里面的内容</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">config </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> config</span><span class="pun">.</span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> config</span><span class="pun">.</span><span class="kwd">ref</span><span class="pun">;</span><span class="pln">
    key </span><span class="pun">=</span><span class="pln"> config</span><span class="pun">.</span><span class="pln">key </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> config</span><span class="pun">.</span><span class="pln">key</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">self</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> config</span><span class="pun">.</span><span class="pln">__self </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> config</span><span class="pun">.</span><span class="pln">__self</span><span class="pun">;</span><span class="pln">
    source </span><span class="pun">=</span><span class="pln"> config</span><span class="pun">.</span><span class="pln">__source </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> config</span><span class="pun">.</span><span class="pln">__source</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// 复制 config 里的内容到 props（如 id 和 className 等）</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propName </span><span class="kwd">in</span><span class="pln"> config</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">config</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propName</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln">
          </span><span class="pun">!</span><span class="pln">RESERVED_PROPS</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propName</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        props</span><span class="pun">[</span><span class="pln">propName</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> config</span><span class="pun">[</span><span class="pln">propName</span><span class="pun">];</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 处理 children，全部挂载到 props 的 children 属性上。如果只有一个参数，直接赋值给 children，</span><span class="pln">
  </span><span class="com">// 否则做合并处理</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> childrenLength </span><span class="pun">=</span><span class="pln"> arguments</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">childrenLength </span><span class="pun">===</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    props</span><span class="pun">.</span><span class="pln">children </span><span class="pun">=</span><span class="pln"> children</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">childrenLength </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> childArray </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">(</span><span class="pln">childrenLength</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> childrenLength</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      childArray</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> arguments</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">];</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    props</span><span class="pun">.</span><span class="pln">children </span><span class="pun">=</span><span class="pln"> childArray</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果某个 prop 为空且存在默认的 prop，则将默认 prop 赋给当前的 prop</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">type </span><span class="pun">&amp;&amp;</span><span class="pln"> type</span><span class="pun">.</span><span class="pln">defaultProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> defaultProps </span><span class="pun">=</span><span class="pln"> type</span><span class="pun">.</span><span class="pln">defaultProps</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propName </span><span class="kwd">in</span><span class="pln"> defaultProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">typeof</span><span class="pln"> props</span><span class="pun">[</span><span class="pln">propName</span><span class="pun">]</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> </span><span class="str">'undefined'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        props</span><span class="pun">[</span><span class="pln">propName</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> defaultProps</span><span class="pun">[</span><span class="pln">propName</span><span class="pun">];</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 返回一个 ReactElement 实例对象</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">ReactElement</span><span class="pun">(</span><span class="pln">type</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">ref</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">,</span><span class="pln"> source</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ReactCurrentOwner</span><span class="pun">.</span><span class="pln">current</span><span class="pun">,</span><span class="pln"> props</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>Virtual DOM 模型通过 createElement 创建虚拟元素，那又是如何创建组件的呢？</p>
<h3><strong>3.2.2　初始化组件入口</strong></h3>
<p>当使用 React 创建组件时，首先会调用 <code>instantiateReactComponent</code>，这是初始化组件的入口函数，它通过判断 node 类型来区分不同组件的入口。</p>
<ul>
<li><p>当 node 为空时，说明 node 不存在，则初始化空组件 <code>ReactEmptyComponent.create(instantiateReactComponent)</code>。</p>
</li>
<li><p>当 node 类型为对象时，即是 DOM 标签组件或自定义组件，那么如果 element 类型为字符串时，则初始化 DOM 标签组件 <code>ReactNativeComponent.createInternalComponent(element)</code>，否则初始化自定义组件 <code>ReactCompositeComponentWrapper()</code>。</p>
</li>
<li><p>当 node 类型为字符串或数字时，则初始化文本组件 <code>ReactNativeComponent.createInstanceForText(node)</code>。</p>
</li>
<li><p>如果是其他情况，则不作处理。</p>
</li>
</ul>
<p><code>instantiateReactComponent</code> 函数关系如图 3-4 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.004.png" alt="{%}"></p>
<p><strong>图 3-4　<code>instantiateReactComponent</code> 函数关系</strong></p>
<p><code>instantiateReactComponent</code>方法的源码如下（源码路径：/v15.0.0/src/renderers/shared/reconciler/instantiateReactComponent.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 初始化组件入口</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> instantiateReactComponent</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> parentCompositeType</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> instance</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 空组件（ReactEmptyComponent）</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">node </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> node </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    instance </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactEmptyComponent</span><span class="pun">.</span><span class="pln">create</span><span class="pun">(</span><span class="pln">instantiateReactComponent</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">typeof</span><span class="pln"> node </span><span class="pun">===</span><span class="pln"> </span><span class="str">'object'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> element </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">typeof</span><span class="pln"> element</span><span class="pun">.</span><span class="pln">type </span><span class="pun">===</span><span class="pln"> </span><span class="str">'string'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// DOM标签（ReactDOMComponent）</span><span class="pln">
      instance </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactNativeComponent</span><span class="pun">.</span><span class="pln">createInternalComponent</span><span class="pun">(</span><span class="pln">element</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isInternalComponentType</span><span class="pun">(</span><span class="pln">element</span><span class="pun">.</span><span class="pln">type</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 不是字符串表示的自定义组件暂无法使用，此处将不做组件初始化操作</span><span class="pln">
      instance </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> element</span><span class="pun">.</span><span class="pln">type</span><span class="pun">(</span><span class="pln">element</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 自定义组件（ReactCompositeComponent）</span><span class="pln">
      instance </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ReactCompositeComponentWrapper</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">typeof</span><span class="pln"> node </span><span class="pun">===</span><span class="pln"> </span><span class="str">'string'</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="kwd">typeof</span><span class="pln"> node </span><span class="pun">===</span><span class="pln"> </span><span class="str">'number'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 字符串或数字（ReactTextComponent）</span><span class="pln">
    instance </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactNativeComponent</span><span class="pun">.</span><span class="pln">createInstanceForText</span><span class="pun">(</span><span class="pln">node</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 不做处理</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 设置实例</span><span class="pln">
  instance</span><span class="pun">.</span><span class="pln">construct</span><span class="pun">(</span><span class="pln">node</span><span class="pun">);</span><span class="pln">
  </span><span class="com">// 初始化参数</span><span class="pln">
  instance</span><span class="pun">.</span><span class="pln">_mountIndex </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  instance</span><span class="pun">.</span><span class="pln">_mountImage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> instance</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<h3><strong>3.2.3　文本组件</strong></h3>
<p>当 node 类型为文本节点时是不算 Virtual DOM 元素的，但 React 为了保持渲染的一致性，将其封装为文本组件 ReactDOMTextComponent。</p>
<p>在执行 <code>mountComponent</code> 方法时，ReactDOMTextComponent 通过 <code>transaction.useCreateElement</code> 判断该文本是否是通过 <code>createElement</code> 方法创建的节点，如果是，则为该节点创建相应的标签和标识 <code>domID</code>，这样每个文本节点也能与其他 React 节点一样拥有自己的唯一标识，同时也拥有了 Virtual DOM diff 的权利。但如果不是通过 <code>createElement</code> 创建的文本，React 将不再为其创建 <code>&lt;span&gt;</code> 和 <code>domID</code> 标识，而是直接返回文本内容。</p>
<p>不再为裸露的文本内容包裹 <code>&lt;span&gt;</code> 标签，是 React 15.0 版本的更新点之一。此前，React 为裸露的文本内容包裹上 <code>&lt;span&gt;</code> 标签，其实并没有产生任何作用，反而增加了不必要的标签，因此 React 15.0 版本将去掉这些操作。</p>
<p>在执行 <code>receiveComponent</code> 方法时，可以通过 <code>DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText)</code> 来更新文本内容。</p>
<p>ReactTextComponent 关系如图 3-5 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.005.png" alt="{%}"></p>
<p><strong>图 3-5　ReactTextComponent 关系</strong></p>
<p>ReactDOMTextComponent 的源码（源码路径：/v15.0.0/src/renderers/dom/shared/ReactDOMTextComponent.js）如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 创建文本组件，这是 ReactText，并不是 ReactElement</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> </span><span class="typ">ReactDOMTextComponent</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">text</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 保存当前的字符串</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement </span><span class="pun">=</span><span class="pln"> text</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_stringText </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> text</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// ReactDOMComponentTree 需要使用的参数</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeNode </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeParent </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 属性</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_domID </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_mountIndex </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_closingComment </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_commentNodes </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span><span class="typ">Object</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">(</span><span class="typ">ReactDOMTextComponent</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  mountComponent</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln"> nativeContainerInfo</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> domID </span><span class="pun">=</span><span class="pln"> nativeContainerInfo</span><span class="pun">.</span><span class="pln">_idCounter</span><span class="pun">++;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> openingValue </span><span class="pun">=</span><span class="pln"> </span><span class="str">' react-text: '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> domID </span><span class="pun">+</span><span class="pln"> </span><span class="str">' '</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> closingValue </span><span class="pun">=</span><span class="pln"> </span><span class="str">' /react-text '</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_domID </span><span class="pun">=</span><span class="pln"> domID</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeParent </span><span class="pun">=</span><span class="pln"> nativeParent</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// 如果使用 createElement 创建文本标签，则该文本会带上标签和 domID</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">.</span><span class="pln">useCreateElement</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> ownerDocument </span><span class="pun">=</span><span class="pln"> nativeContainerInfo</span><span class="pun">.</span><span class="pln">_ownerDocument</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> openingComment </span><span class="pun">=</span><span class="pln"> ownerDocument</span><span class="pun">.</span><span class="pln">createComment</span><span class="pun">(</span><span class="pln">openingValue</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> closingComment </span><span class="pun">=</span><span class="pln"> ownerDocument</span><span class="pun">.</span><span class="pln">createComment</span><span class="pun">(</span><span class="pln">closingValue</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> lazyTree </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DOMLazyTree</span><span class="pun">(</span><span class="pln">ownerDocument</span><span class="pun">.</span><span class="pln">createDocumentFragment</span><span class="pun">());</span><span class="pln">
      </span><span class="com">// 开始标签</span><span class="pln">
      </span><span class="typ">DOMLazyTree</span><span class="pun">.</span><span class="pln">queueChild</span><span class="pun">(</span><span class="pln">lazyTree</span><span class="pun">,</span><span class="pln"> </span><span class="typ">DOMLazyTree</span><span class="pun">(</span><span class="pln">openingComment</span><span class="pun">));</span><span class="pln">
      </span><span class="com">// 如果是文本类型，则创建文本节点</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_stringText</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="typ">DOMLazyTree</span><span class="pun">.</span><span class="pln">queueChild</span><span class="pun">(</span><span class="pln">lazyTree</span><span class="pun">,</span><span class="pln"> </span><span class="typ">DOMLazyTree</span><span class="pun">(</span><span class="pln">ownerDocument</span><span class="pun">.</span><span class="pln">createTextNode
          </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_stringText</span><span class="pun">)));</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="com">// 结束标签</span><span class="pln">
      </span><span class="typ">DOMLazyTree</span><span class="pun">.</span><span class="pln">queueChild</span><span class="pun">(</span><span class="pln">lazyTree</span><span class="pun">,</span><span class="pln"> </span><span class="typ">DOMLazyTree</span><span class="pun">(</span><span class="pln">closingComment</span><span class="pun">));</span><span class="pln">
      </span><span class="typ">ReactDOMComponentTree</span><span class="pun">.</span><span class="pln">precacheNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> openingComment</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_closingComment </span><span class="pun">=</span><span class="pln"> closingComment</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> lazyTree</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> escapedText </span><span class="pun">=</span><span class="pln"> escapeTextContentForBrowser</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_stringText</span><span class="pun">);</span><span class="pln">
      </span><span class="com">// 静态页面下直接返回文本</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">.</span><span class="pln">renderToStaticMarkup</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> escapedText</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="com">// 如果不是通过 createElement 创建的文本，则将标签和属性注释掉，直接返回文本内容</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="str">'&lt;!--'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> openingValue </span><span class="pun">+</span><span class="pln"> </span><span class="str">'--&gt;'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> escapedText </span><span class="pun">+</span><span class="pln">
        </span><span class="str">'&lt;!--'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> closingValue </span><span class="pun">+</span><span class="pln"> </span><span class="str">'--&gt;'</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
  </span><span class="com">// 更新文本内容</span><span class="pln">
  receiveComponent</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">nextComponent</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextText </span><span class="pun">!==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement </span><span class="pun">=</span><span class="pln"> nextText</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> nextStringText </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> nextText</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextStringText </span><span class="pun">!==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_stringText</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_stringText </span><span class="pun">=</span><span class="pln"> nextStringText</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">var</span><span class="pln"> commentNodes </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">getNativeNode</span><span class="pun">();</span><span class="pln">
        </span><span class="typ">DOMChildrenOperations</span><span class="pun">.</span><span class="pln">replaceDelimitedText</span><span class="pun">(</span><span class="pln">commentNodes</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> commentNodes</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln">
          nextStringText</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<h3><strong>3.2.4　DOM 标签组件</strong></h3>
<p>Virtual DOM 模型涵盖了几乎所有的原生 DOM 标签，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;span&gt;</code> 等。当开发者使用 React 时，此时的 <code>&lt;div&gt;</code> 并不是原生 <code>&lt;div&gt;</code> 标签，它其实是 React 生成的 Virtual DOM 对象，只不过标签名称相同罢了。React 的大部分工作都是在 Virtual DOM 中完成的，对于原生 DOM 而言，Virtual DOM 就如同一个隔离的沙盒，因此 React 的处理并不是直接操作和污染原生 DOM，这样不仅保持了性能上的高效和稳定，而且降低了直接操作原生 DOM 而导致错误的风险。</p>
<p>ReactDOMComponent 针对 Virtual DOM 标签的处理主要分为以下两个部分：</p>
<ul>
<li><p>属性的更新，包括更新样式、更新属性、处理事件等；</p>
</li>
<li><p>子节点的更新，包括更新内容、更新子节点，此部分涉及 diff 算法。</p>
</li>
</ul>
<p><strong>1. 更新属性</strong></p>
<p>当执行 <code>mountComponent</code> 方法时，ReactDOMComponent 首先会生成标记和标签，通过 <code>this.createOpenTagMarkupAndPutListeners(transaction)</code> 来处理 DOM 节点的属性和事件。</p>
<ul>
<li><p>如果存在事件，则针对当前的节点添加事件代理，即调用 <code>enqueuePutListener(this, propKey, propValue, transaction)</code>。</p>
</li>
<li><p>如果存在样式，首先会对样式进行合并操作 <code>Object.assign({}, props.style)</code>，然后通过 <code>CSSPropertyOperations.createMarkupForStyles(propValue, this)</code> 创建样式。</p>
</li>
<li><p>通过 <code>DOMPropertyOperations.createMarkupForProperty(propKey, propValue)</code> 创建属性。</p>
</li>
<li><p>通过 <code>DOMPropertyOperations.createMarkupForID(this._domID)</code> 创建唯一标识。</p>
</li>
</ul>
<p><code>_createOpenTagMarkupAndPutListeners</code> 方法的源码如下（源码路径：/v15.0.0/src/renderers/dom/shared/ReactDOMComponent.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">_createOpenTagMarkupAndPutListeners</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> ret </span><span class="pun">=</span><span class="pln"> </span><span class="str">'&lt;'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement</span><span class="pun">.</span><span class="pln">type</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 拼凑出属性</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> propKey </span><span class="kwd">in</span><span class="pln"> props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> propValue </span><span class="pun">=</span><span class="pln"> props</span><span class="pun">[</span><span class="pln">propKey</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">registrationNameModules</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 针对当前的节点添加事件代理</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propValue</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        enqueuePutListener</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> propKey</span><span class="pun">,</span><span class="pln"> propValue</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propKey </span><span class="pun">===</span><span class="pln"> STYLE</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propValue</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          </span><span class="com">// 合并样式</span><span class="pln">
          propValue </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_previousStyleCopy </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">({},</span><span class="pln"> props</span><span class="pun">.</span><span class="pln">style</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        propValue </span><span class="pun">=</span><span class="pln"> </span><span class="typ">CSSPropertyOperations</span><span class="pun">.</span><span class="pln">createMarkupForStyles</span><span class="pun">(</span><span class="pln">propValue</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="com">// 创建属性标识</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> markup </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_tag </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> isCustomComponent</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_tag</span><span class="pun">,</span><span class="pln"> props</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        markup </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DOMPropertyOperations</span><span class="pun">.</span><span class="pln">createMarkupForProperty</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">,</span><span class="pln"> propValue</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">markup</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        ret </span><span class="pun">+=</span><span class="pln"> </span><span class="str">' '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> markup</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 对于静态页面，不需要设置 react-id，这样可以节省大量字节</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">.</span><span class="pln">renderToStaticMarkup</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> ret</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 设置 react-id</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeParent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    ret </span><span class="pun">+=</span><span class="pln"> </span><span class="str">' '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="typ">DOMPropertyOperations</span><span class="pun">.</span><span class="pln">createMarkupForRoot</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  ret </span><span class="pun">+=</span><span class="pln"> </span><span class="str">' '</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="typ">DOMPropertyOperations</span><span class="pun">.</span><span class="pln">createMarkupForID</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_domID</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> ret</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<blockquote>
<p><strong>注意</strong>　去除 <code>data-reactid</code> 是 React 15.0 的更新点之一。众所周知，React 渲染后的每个 DOM 节点都会添加 <code>data-reactid</code> 属性。这个作为 DOM 节点的唯一标识而存在的字符串，不仅对用户毫无用处，而且还会存在一定的性能影响。因为当 DOM 更新时，每个节点的 <code>data-reactid</code> 属性也会进行更新，而更新 DOM 节点属性是需要部分性能消耗的。其实，早有开发者向 React 官方提过问题，建议去掉这个鸡肋的属性标识，这终于在 React 15.0 版本上实现了。据官方宣称，去除 <code>data-reactid</code> 使得 React 性能有了 10% 的提升。</p>
</blockquote>
<p>当执行<code>receiveComponent</code>方法时，ReactDOMComponent会通过<code>this.updateComponent(transaction, prevElement, nextElement, context)</code> 来更新 DOM 节点属性。</p>
<p>先是<strong>删除不需要的旧属性</strong>。如果不需要旧样式，则遍历旧样式集合，并对每个样式进行置空删除；如果不需要事件，则将其事件监听的属性去掉，即针对当前的节点取消事件代理 <code>deleteListener(this, propKey)</code>；如果旧属性不在新属性集合里时，则需要删除旧属性 <code>DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey)</code>。</p>
<p>再是<strong>更新新属性</strong>。如果存在新样式，则将新样式进行合并 <code>Object.assign({}, nextProp)</code>；如果在旧样式中但不在新样式中，则清除该样式；如果既在旧样式中也在新样式中，且不相同，则更新该样式 <code>styleUpdates[styleName] = nextProp[styleName]</code>；如果在新样式中，但不在旧样式中，则直接更新为新样式 <code>styleUpdates = nextProp</code>；如果存在事件更新，则添加事件监听的属性 <code>enqueuePutListener(this, propKey, nextProp, transaction)</code>；如果存在新属性，则添加新属性，或者更新旧的同名属性<code>DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp)</code>。</p>
<p>至此，ReactDOMComponent 完成了 DOM 节点属性更新的操作，相关代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">_updateDOMProperties</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">lastProps</span><span class="pun">,</span><span class="pln"> nextProps</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> propKey</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> styleName</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> styleUpdates</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 当一个旧的属性不在新的属性集合里时，需要删除</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propKey </span><span class="kwd">in</span><span class="pln"> lastProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 如果新属性里有，或者 propKey 是在原型上的则直接跳过，这样剩下的都是不在新属性集合里的，</span><span class="pln">
    </span><span class="com">// 需要删除</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="pun">!</span><span class="pln">lastProps</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> lastProps</span><span class="pun">[</span><span class="pln">propKey</span><span class="pun">]</span><span class="pln">
      </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// 从 DOM 上删除不需要的样式</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propKey </span><span class="pun">===</span><span class="pln"> STYLE</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> lastStyle </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_previousStyleCopy</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">styleName </span><span class="kwd">in</span><span class="pln"> lastStyle</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lastStyle</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">styleName</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          styleUpdates </span><span class="pun">=</span><span class="pln"> styleUpdates </span><span class="pun">||</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
          styleUpdates</span><span class="pun">[</span><span class="pln">styleName</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_previousStyleCopy </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">registrationNameModules</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lastProps</span><span class="pun">[</span><span class="pln">propKey</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          </span><span class="com">// 这里的事件监听的属性需要去掉监听，针对当前的节点取消事件代理</span><span class="pln">
         deleteListener</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> propKey</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">DOMProperty</span><span class="pun">.</span><span class="pln">isStandardName</span><span class="pun">[</span><span class="pln">propKey</span><span class="pun">]</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="typ">DOMProperty</span><span class="pun">.</span><span class="pln">isCustomAttribute</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 从 DOM 上删除不需要的属性</span><span class="pln">
      </span><span class="typ">DOMPropertyOperations</span><span class="pun">.</span><span class="pln">deleteValueForProperty</span><span class="pun">(</span><span class="pln">getNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">),</span><span class="pln"> propKey</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 对于新的属性，需要写到 DOM 节点上</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propKey </span><span class="kwd">in</span><span class="pln"> nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> nextProp </span><span class="pun">=</span><span class="pln"> nextProps</span><span class="pun">[</span><span class="pln">propKey</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> lastProp </span><span class="pun">=</span><span class="pln">
        propKey </span><span class="pun">===</span><span class="pln"> STYLE </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_previousStyleCopy </span><span class="pun">:</span><span class="pln">
        lastProps </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> lastProps</span><span class="pun">[</span><span class="pln">propKey</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// 不在新属性中，或与旧属性相同，则跳过</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">nextProps</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> nextProp </span><span class="pun">===</span><span class="pln"> lastProp </span><span class="pun">||</span><span class="pln"> nextProp </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> lastProp
      </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// 在 DOM 上写入新样式（更新样式）</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">propKey </span><span class="pun">===</span><span class="pln"> STYLE</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextProp</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        nextProp </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_previousStyleCopy </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">({},</span><span class="pln"> nextProp</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lastProp</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// 在旧样式中且不在新样式中，清除该样式</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">styleName </span><span class="kwd">in</span><span class="pln"> lastProp</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lastProp</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">styleName</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">nextProp
            </span><span class="pun">||</span><span class="pln"> </span><span class="pun">!</span><span class="pln">nextProp</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">styleName</span><span class="pun">)))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            styleUpdates </span><span class="pun">=</span><span class="pln"> styleUpdates </span><span class="pun">||</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
            styleUpdates</span><span class="pun">[</span><span class="pln">styleName</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln">
          </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="com">// 既在旧样式中也在新样式中，且不相同，更新该样式</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">styleName </span><span class="kwd">in</span><span class="pln"> nextProp</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextProp</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">styleName</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> lastProp</span><span class="pun">[</span><span class="pln">styleName</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!==</span><span class="pln"> nextProp</span><span class="pun">[</span><span class="pln">styleName</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            styleUpdates </span><span class="pun">=</span><span class="pln"> styleUpdates </span><span class="pun">||</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
            styleUpdates</span><span class="pun">[</span><span class="pln">styleName</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nextProp</span><span class="pun">[</span><span class="pln">styleName</span><span class="pun">];</span><span class="pln">
          </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
      </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// 不存在旧样式，直接写入新样式</span><span class="pln">
        styleUpdates </span><span class="pun">=</span><span class="pln"> nextProp</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">registrationNameModules</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextProp</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// 添加事件监听的属性</span><span class="pln">
        enqueuePutListener</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> propKey</span><span class="pun">,</span><span class="pln"> nextProp</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        deleteListener</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> propKey</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// 添加新的属性，或者是更新旧的同名属性</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isCustomComponent</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_tag</span><span class="pun">,</span><span class="pln"> nextProps</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">RESERVED_PROPS</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// setValueForAttribute 更新属性</span><span class="pln">
        </span><span class="typ">DOMPropertyOperations</span><span class="pun">.</span><span class="pln">setValueForAttribute</span><span class="pun">(</span><span class="pln">getNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">),</span><span class="pln"> propKey</span><span class="pun">,</span><span class="pln"> nextProp</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">DOMProperty</span><span class="pun">.</span><span class="pln">properties</span><span class="pun">[</span><span class="pln">propKey</span><span class="pun">]</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="typ">DOMProperty</span><span class="pun">.</span><span class="pln">isCustomAttribute</span><span class="pun">(</span><span class="pln">propKey</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> node </span><span class="pun">=</span><span class="pln"> getNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextProp </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="typ">DOMPropertyOperations</span><span class="pun">.</span><span class="pln">setValueForProperty</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> propKey</span><span class="pun">,</span><span class="pln"> nextProp</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// 如果更新为 null 或 undefined，则执行删除属性操作</span><span class="pln">
        </span><span class="typ">DOMPropertyOperations</span><span class="pun">.</span><span class="pln">deleteValueForProperty</span><span class="pun">(</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> propKey</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// 如果 styleUpdates 不为空，则设置新样式</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">styleUpdates</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="typ">CSSPropertyOperations</span><span class="pun">.</span><span class="pln">setValueForStyles</span><span class="pun">(</span><span class="pln">getNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">),</span><span class="pln"> styleUpdates</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><strong>2. 更新子节点</strong></p>
<p>当执行 <code>mountComponent</code> 方法时，ReactDOMComponent 会通过 <code>this._createContentMarkup(transaction, props, context)</code> 来处理 DOM 节点的内容。</p>
<p>首先，获取节点内容 <code>props.dangerouslySetInnerHTML</code>。如果存在子节点，则通过 <code>this.mountChildren(childrenToUse, transaction, context)</code> 对子节点进行初始化渲染：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">_createContentMarkup</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> props</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> ret </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 获取子节点渲染出的内容</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> innerHTML </span><span class="pun">=</span><span class="pln"> props</span><span class="pun">.</span><span class="pln">dangerouslySetInnerHTML</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">innerHTML </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">innerHTML</span><span class="pun">.</span><span class="pln">__html </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      ret </span><span class="pun">=</span><span class="pln"> innerHTML</span><span class="pun">.</span><span class="pln">__html</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> contentToUse </span><span class="pun">=</span><span class="pln"> CONTENT_TYPES</span><span class="pun">[</span><span class="kwd">typeof</span><span class="pln"> props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">]</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> props</span><span class="pun">.</span><span class="pln">children </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> childrenToUse </span><span class="pun">=</span><span class="pln"> contentToUse </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">contentToUse </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      ret </span><span class="pun">=</span><span class="pln"> escapeTextContentForBrowser</span><span class="pun">(</span><span class="pln">contentToUse</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">childrenToUse </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 对子节点进行初始化渲染</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> mountImages </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">mountChildren</span><span class="pun">(</span><span class="pln">childrenToUse</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">);</span><span class="pln">
      ret </span><span class="pun">=</span><span class="pln"> mountImages</span><span class="pun">.</span><span class="pln">join</span><span class="pun">(</span><span class="str">''</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 是否需要换行</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">newlineEatingTags</span><span class="pun">[</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_tag</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> ret</span><span class="pun">.</span><span class="pln">charAt</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="str">'\n'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> ret</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> ret</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>当执行 <code>receiveComponent</code> 方法时，ReactDOMComponent 会通过 <code>this._updateDOMChildren(lastProps, nextProps, transaction, context)</code> 来更新 DOM 内容和子节点。</p>
<p>先是<strong>删除不需要的子节点和内容</strong>。如果旧节点存在，而新节点不存在，说明当前节点在更新后被删除，此时执行方法 <code>this.updateChildren(null, transaction, context)</code>；如果旧的内容存在，而新的内容不存在，说明当前内容在更新后被删除，此时执行方法 <code>this.updateTextContent('')</code>。</p>
<p>再是<strong>更新子节点和内容</strong>。如果新子节点存在，则更新其子节点，此时执行方法 <code>this.updateChildren(nextChildren, transaction, context)</code>；如果新的内容存在，则更新内容，此时执行方法 <code>this.updateTextContent('' + nextContent)</code>。</p>
<p>至此，ReactDOMComponent 完成了 DOM 子节点和内容的更新操作，相关代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">_updateDOMChildren</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">lastProps</span><span class="pun">,</span><span class="pln"> nextProps</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 初始化</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> lastContent </span><span class="pun">=</span><span class="pln"> CONTENT_TYPES</span><span class="pun">[</span><span class="kwd">typeof</span><span class="pln"> lastProps</span><span class="pun">.</span><span class="pln">children</span><span class="pun">]</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> lastProps</span><span class="pun">.</span><span class="pln">children </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextContent </span><span class="pun">=</span><span class="pln"> CONTENT_TYPES</span><span class="pun">[</span><span class="kwd">typeof</span><span class="pln"> nextProps</span><span class="pun">.</span><span class="pln">children</span><span class="pun">]</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> nextProps</span><span class="pun">.</span><span class="pln">children </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> lastHtml </span><span class="pun">=</span><span class="pln"> lastProps</span><span class="pun">.</span><span class="pln">dangerouslySetInnerHTML </span><span class="pun">&amp;&amp;</span><span class="pln"> lastProps</span><span class="pun">.</span><span class="pln">dangerouslySetInnerHTML</span><span class="pun">.</span><span class="pln">__html</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextHtml </span><span class="pun">=</span><span class="pln"> nextProps</span><span class="pun">.</span><span class="pln">dangerouslySetInnerHTML </span><span class="pun">&amp;&amp;</span><span class="pln"> nextProps</span><span class="pun">.</span><span class="pln">dangerouslySetInnerHTML</span><span class="pun">.</span><span class="pln">__html</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> lastChildren </span><span class="pun">=</span><span class="pln"> lastContent </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> lastProps</span><span class="pun">.</span><span class="pln">children</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextChildren </span><span class="pun">=</span><span class="pln"> nextContent </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> nextProps</span><span class="pun">.</span><span class="pln">children</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> lastHasContentOrHtml </span><span class="pun">=</span><span class="pln"> lastContent </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> lastHtml </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextHasContentOrHtml </span><span class="pun">=</span><span class="pln"> nextContent </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> nextHtml </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lastChildren </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> nextChildren </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 旧节点存在，而新节点不存在，说明当前节点在更新后被删除了</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updateChildren</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lastHasContentOrHtml </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">nextHasContentOrHtml</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 说明当前内容在更新后被删除了</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updateTextContent</span><span class="pun">(</span><span class="str">''</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 新节点存在</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextContent </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 更新内容</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lastContent </span><span class="pun">!==</span><span class="pln"> nextContent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updateTextContent</span><span class="pun">(</span><span class="str">''</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> nextContent</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextHtml </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 更新属性标识</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lastHtml </span><span class="pun">!==</span><span class="pln"> nextHtml</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updateMarkup</span><span class="pun">(</span><span class="str">''</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> nextHtml</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextChildren </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 更新子节点</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updateChildren</span><span class="pun">(</span><span class="pln">nextChildren</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>当卸载组件时，ReactDOMComponent 会进行一系列的操作，如卸载子节点、清除事件监听、清空标识等：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">unmountComponent</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">safely</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">unmountChildren</span><span class="pun">(</span><span class="pln">safely</span><span class="pun">);</span><span class="pln">
  </span><span class="typ">ReactDOMComponentTree</span><span class="pun">.</span><span class="pln">uncacheNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="typ">EventPluginHub</span><span class="pun">.</span><span class="pln">deleteAllListeners</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="typ">ReactComponentBrowserEnvironment</span><span class="pun">.</span><span class="pln">unmountIDFromEnvironment</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_rootNodeID</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_rootNodeID </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_domID </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_wrapperState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>ReactDOMComponent 关系如图 3-6 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.006.png" alt="{%}"></p>
<p><strong>图 3-6　ReactDOMComponent关系</strong></p>
<p>其中，updateChildren 为 diff 中的内容，请移步至 3.5 节。</p>
<h3><strong>3.2.5　自定义组件</strong></h3>
<p>ReactCompositeComponent 自定义组件实现了一整套 React 生命周期和 setState 机制，因此自定义组件是在生命周期的环境中进行更新属性、内容和子节点的操作。这些更新操作与 ReactDOMComponent 的操作类似，在此就不赘述了。</p>
<p>如果对 React 生命周期机制不了解，下一节就可以让你深入了解生命周期的管理艺术。</p>
<p>ReactCompositeComponent 关系如图 3-7 所示。</p>
<p class="图"><img src="http://epub.ituring.com.cn/api/storage/getbykey/screenshow?key=170206e664fe080b4414" alt="图像说明文字"></p>
<p><strong>图 3-7　ReactCompositeComponent 关系</strong></p>
<h2><strong>3.3　生命周期的管理艺术</strong></h2>
<p>对于 React 组件，生命周期是它的核心概念之一。在 1.5 节中，我们已经大概了解了生命周期的概念及用法，本节将深入源码来剖析 React 生命周期的管理艺术。</p>
<p>React 的主要思想是通过构建可复用组件来构建用户界面。所谓组件，其实就是有限状态机（FSM），通过状态渲染对应的界面，且每个组件都有自己的生命周期，它规定了组件的状态和方法需要在哪个阶段改变和执行。</p>
<p>有限状态机，表示有限个状态以及在这些状态之间的转移和动作等行为的模型。一般通过状态、事件、转换和动作来描述有限状态机。图 3-8 是描述组合锁状态机的模型图，包括 5 个状态、5 个状态自转换、6 个状态间转换和 1 个复位 RESET 转换到状态 s1。状态机能够记住目前所处的状态，可以根据当前的状态做出相应的决策，并且可以在进入不同的状态时做不同的操作。状态机将复杂的关系简单化，利用这种自然而直观的方式可以让代码更容易理解。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.008.png" alt="{%}"></p>
<p><strong>图 3-8　状态机模型</strong></p>
<p>React 正是利用这一概念，通过管理状态来实现对组件的管理。例如，某个组件有显示和隐藏两个状态，通常会设计两个方法 <code>show()</code> 和 <code>hide()</code> 来实现切换，而 React 只需要设置状态 <code>setState({ showed: true/false })</code> 即可实现。同时，React 还引入了组件的生命周期这个概念。通过它，就可以实现组件的状态机控制，从而达到“生命周期→状态→组件”的和谐画面。</p>
<p>虽然组件、状态机、生命周期这三者都不是 React 独创的，但 Web Components 标准与其中的自定义组件的生命周期的概念相似。就目前而言，React 是将这几种概念结合得相对清晰、流畅的 View 实现。</p>
<h3><strong>3.3.1　初探 React 生命周期</strong></h3>
<p>在自定义 React 组件时，我们会根据需要在组件生命周期的不同阶段实现不同的逻辑。为了查看组件生命周期的执行顺序，推荐使用 react-lifecycle mixin。将此 mixin 添加到需要观察的组件中，当任何生命周期方法被调用时，就能在控制台观察到对应的生命周期的调用时状态。</p>
<p>通过反复试验，我们得到了组件的生命周期在不同状态下的执行顺序。</p>
<ul>
<li><p>当首次挂载组件时，按顺序执行 <code>getDefaultProps</code>、<code>getInitialState</code>、<code>componentWillMount</code>、<code>render</code> 和 <code>componentDidMount</code>。</p>
</li>
<li><p>当卸载组件时，执行 <code>componentWillUnmount</code>。</p>
</li>
<li><p>当重新挂载组件时，此时按顺序执行 <code>getInitialState</code>、<code>componentWillMount</code>、<code>render</code> 和 <code>componentDidMount</code>，但并不执行 <code>getDefaultProps</code>。</p>
</li>
<li><p>当再次渲染组件时，组件接受到更新状态，此时按顺序执行 <code>componentWillReceiveProps</code>、<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>render</code> 和 <code>componentDidUpdate</code>。</p>
</li>
</ul>
<p>当使用 ES6 classes 构建 React 组件时，<code>static defaultProps = {}</code> 其实就是调用内部的 <code>getDefaultProps</code> 方法，<code>constructor</code> 中的 <code>this.state = {}</code> 其实就是调用内部的 <code>getInitialState</code> 方法。因此，源码解读的部分与用 <code>createClass</code> 方法构建组件一样。</p>
<p>生命周期的执行顺序如图 3-9 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.009.png" alt="{%}"></p>
<p><strong>图 3-9　生命周期的执行顺序</strong></p>
<p>那么，为何 React 会按上述顺序执行生命周期？为何多次渲染时，React 会执行生命周期的不同阶段？为何 <code>getDefaultProps</code> 只执行了一次？</p>
<h3><strong>3.3.2　详解 React 生命周期</strong></h3>
<p>自定义组件（ReactCompositeComponent）的生命周期主要通过 3 个阶段进行管理——MOUNTING、RECEIVE_PROPS 和 UNMOUNTING，它们负责通知组件当前所处的阶段，应该执行生命周期中的哪个步骤。这 3 个阶段对应 3 种方法，分别为：<code>mountComponent</code>、<code>updateComponent</code>和 <code>unmountComponent</code>，每个方法都提供了几种处理方法，其中带 <code>will</code> 前缀的方法在进入状态之前调用，带 <code>did</code> 前缀的方法在进入状态之后调用。3 个阶段共包括 5 种处理方法，还有两种特殊状态的处理方法。</p>
<p>生命周期的 3 个阶段如图 3-10 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.010.png" alt="{%}"></p>
<p><strong>图 3-10　生命周期的 3 个阶段</strong></p>
<p><strong>1. 使用 <code>createClass</code> 创建自定义组件</strong></p>
<p><code>createClass</code> 是创建自定义组件的入口方法，负责管理生命周期中的 <code>getDefaultProps</code>。该方法在整个生命周期中只执行一次，这样所有实例初始化的 props 将会被共享。</p>
<p>通过 <code>createClass</code> 创建自定义组件，利用原型继承 <code>ReactClassComponent</code> 父类，按顺序合并 mixin，设置初始化 <code>defaultProps</code>，返回构造函数。</p>
<p>当使用 ES6 classes 编写 React 组件时，<code>class MyComponent extends React.Component</code> 其实就是调用内部方法 <code>createClass</code> 创建组件，相关代码如下（源码路径：/v15.0.0/src/isomorphic/classic/class/ReactClass.js#L802）：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">var</span><span class="pln"> </span><span class="typ">ReactClass</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 创建自定义组件</span><span class="pln">
  createClass</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">spec</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> </span><span class="typ">Constructor</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">props</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">,</span><span class="pln"> updater</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 自动绑定</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">__reactAutoBindPairs</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        bindAutoBindMethods</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props </span><span class="pun">=</span><span class="pln"> props</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">context </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">refs </span><span class="pun">=</span><span class="pln"> emptyObject</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updater </span><span class="pun">=</span><span class="pln"> updater </span><span class="pun">||</span><span class="pln"> </span><span class="typ">ReactNoopUpdateQueue</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
      </span><span class="com">// ReactClass 没有构造函数，通过 getInitialState 和 componentWillMount 来代替</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> initialState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">getInitialState </span><span class="pun">?</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">getInitialState</span><span class="pun">()</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> initialState</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
    </span><span class="com">// 原型继承父类</span><span class="pln">
    </span><span class="typ">Constructor</span><span class="pun">.</span><span class="pln">prototype </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ReactClassComponent</span><span class="pun">();</span><span class="pln">
    </span><span class="typ">Constructor</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">constructor </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Constructor</span><span class="pun">;</span><span class="pln">
    </span><span class="typ">Constructor</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">__reactAutoBindPairs </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[];</span><span class="pln">
    </span><span class="com">// 合并 mixin</span><span class="pln">
    injectedMixins</span><span class="pun">.</span><span class="pln">forEach</span><span class="pun">(</span><span class="pln">
      mixSpecIntoComponent</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Constructor</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
    mixSpecIntoComponent</span><span class="pun">(</span><span class="typ">Constructor</span><span class="pun">,</span><span class="pln"> spec</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// 所有 mixin 合并后初始化 defaultProps(在整个生命周期中，getDefaultProps 只执行一次)</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Constructor</span><span class="pun">.</span><span class="pln">getDefaultProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="typ">Constructor</span><span class="pun">.</span><span class="pln">defaultProps </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Constructor</span><span class="pun">.</span><span class="pln">getDefaultProps</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="com">// 减少查找并设置原型的时间</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> methodName </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">ReactClassInterface</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="typ">Constructor</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">[</span><span class="pln">methodName</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="typ">Constructor</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">[</span><span class="pln">methodName</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Constructor</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p><strong>2. 阶段一：MOUNTING</strong></p>
<p><code>mountComponent</code> 负责管理生命周期中的 <code>getInitialState</code>、<code>componentWillMount</code>、<code>render</code> 和 <code>componentDidMount</code>。</p>
<p>由于 <code>getDefaultProps</code> 是通过构造函数进行管理的，所以也是整个生命周期中最先开始执行的。而 <code>mountComponent</code> 只能望洋兴叹，无法调用到 <code>getDefaultProps</code>。这就解释了为何 <code>getDefaultProps</code>只执行一次。</p>
<p>由于通过 <code>ReactCompositeComponentBase</code> 返回的是一个虚拟节点，所以需要利用 <code>instantiateReactComponent</code> 去得到实例，再使用 <code>mountComponent</code> 拿到结果作为当前自定义元素的结果。</p>
<p>通过 <code>mountComponent</code> 挂载组件，初始化序号、标记等参数，判断是否为无状态组件，并进行对应的组件初始化工作，比如初始化 props、context 等参数。利用 <code>getInitialState</code> 获取初始化 state、初始化更新队列和更新状态。</p>
<p>若存在 <code>componentWillMount</code>，则执行。如果此时在 <code>componentWillMount</code> 中调用 <code>setState</code> 方法，是不会触发 <code>re-render</code>的，而是会进行 state 合并，且 <code>inst.state = this._processPendingState (inst.props, inst.context)</code> 是在 <code>componentWillMount</code> 之后执行的，因此 <code>componentWillMount</code> 中的 <code>this.state</code> 并不是最新的，在 <code>render</code> 中才可以获取更新后的 <code>this.state</code>。</p>
<p>因此，React 是利用更新队列 <code>this._pendingStateQueue</code> 以及更新状态 <code>this._pendingReplaceState</code> 和 <code>this._pendingForceUpdate</code> 来实现 <code>setState</code> 的异步更新机制。</p>
<p>当渲染完成后，若存在 <code>componentDidMount</code>，则调用。这就解释了 <code>componentWillMount</code>、<code>render</code>、<code>componentDidMount</code> 这三者之间的执行顺序。</p>
<p>其实，<code>mountComponent</code> 本质上是通过<strong>递归</strong>渲染内容的，由于递归的特性，父组件的 <code>componentWillMount</code> 在其子组件的 <code>componentWillMount</code> 之前调用，而父组件的 <code>componentDidMount</code> 在其子组件的 <code>componentDidMount</code> 之后调用。</p>
<p><code>mountComponent</code> 的执行顺序如图 3-11 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.011.png" alt="" width="70%" style="width: 70%"></p>
<p><strong>图 3-11　<code>mountComponent</code> 的执行顺序</strong></p>
<p><code>mountComponent</code> 的代码如下（源码路径：/v15.0.0/src/renderers/shared/reconciler/ReactCompositeComponent.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 当组件挂载时，会分配一个递增编号，表示执行 ReactUpdates 时更新组件的顺序</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> nextMountID </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
</span><span class="com">// 初始化组件，渲染标记，注册事件监听器</span><span class="pln">
mountComponent</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln"> nativeContainerInfo</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 当前元素对应的上下文</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_mountOrder </span><span class="pun">=</span><span class="pln"> nextMountID</span><span class="pun">++;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeParent </span><span class="pun">=</span><span class="pln"> nativeParent</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeContainerInfo </span><span class="pun">=</span><span class="pln"> nativeContainerInfo</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> publicProps </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processProps</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement</span><span class="pun">.</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> publicContext </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processContext</span><span class="pun">(</span><span class="pln">context</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement</span><span class="pun">.</span><span class="pln">type</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 初始化公共类</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> inst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_constructComponent</span><span class="pun">(</span><span class="pln">publicProps</span><span class="pun">,</span><span class="pln"> publicContext</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> renderedElement</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 用于判断组件是否为 stateless，无状态组件没有状态更新队列，它只专注于渲染</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">shouldConstruct</span><span class="pun">(</span><span class="typ">Component</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">inst </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">render </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    renderedElement </span><span class="pun">=</span><span class="pln"> inst</span><span class="pun">;</span><span class="pln">
    warnIfInvalidElement</span><span class="pun">(</span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> renderedElement</span><span class="pun">);</span><span class="pln">
    inst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StatelessComponent</span><span class="pun">(</span><span class="typ">Component</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 这些初始化参数本应该在构造函数中设置，在此设置是为了便于进行简单的类抽象</span><span class="pln">
  inst</span><span class="pun">.</span><span class="pln">props </span><span class="pun">=</span><span class="pln"> publicProps</span><span class="pun">;</span><span class="pln">
  inst</span><span class="pun">.</span><span class="pln">context </span><span class="pun">=</span><span class="pln"> publicContext</span><span class="pun">;</span><span class="pln">
  inst</span><span class="pun">.</span><span class="pln">refs </span><span class="pun">=</span><span class="pln"> emptyObject</span><span class="pun">;</span><span class="pln">
  inst</span><span class="pun">.</span><span class="pln">updater </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactUpdateQueue</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance </span><span class="pun">=</span><span class="pln"> inst</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 将实例存储为一个引用</span><span class="pln">
  </span><span class="typ">ReactInstanceMap</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="pln">inst</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="com">// 初始化 state</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> initialState </span><span class="pun">=</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">initialState </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    inst</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> initialState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 初始化更新队列</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingStateQueue </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingReplaceState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingForceUpdate </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> markup</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 如果挂载时出现错误</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">unstable_handleError</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    markup </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">performInitialMountWithErrorHandling</span><span class="pun">(</span><span class="pln">renderedElement</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln">
      nativeContainerInfo</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 执行初始化挂载</span><span class="pln">
    markup </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">performInitialMount</span><span class="pun">(</span><span class="pln">renderedElement</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln"> nativeContainerInfo</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln">
      context</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果存在 componentDidMount，则调用</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">componentDidMount</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    transaction</span><span class="pun">.</span><span class="pln">getReactMountReady</span><span class="pun">().</span><span class="pln">enqueue</span><span class="pun">(</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">componentDidMount</span><span class="pun">,</span><span class="pln"> inst</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> markup</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
performInitialMountWithErrorHandling</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">renderedElement</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln"> nativeContainerInfo</span><span class="pun">,</span><span class="pln">
  transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> markup</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> checkpoint </span><span class="pun">=</span><span class="pln"> transaction</span><span class="pun">.</span><span class="pln">checkpoint</span><span class="pun">();</span><span class="pln">
  </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 捕捉错误，如果没有错误，则初始化挂载</span><span class="pln">
    markup </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">performInitialMount</span><span class="pun">(</span><span class="pln">renderedElement</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln"> nativeContainerInfo</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln">
      context</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    transaction</span><span class="pun">.</span><span class="pln">rollback</span><span class="pun">(</span><span class="pln">checkpoint</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance</span><span class="pun">.</span><span class="pln">unstable_handleError</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingStateQueue</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processPendingState</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance</span><span class="pun">.</span><span class="pln">props</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance</span><span class="pun">.</span><span class="pln">context</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    checkpoint </span><span class="pun">=</span><span class="pln"> transaction</span><span class="pun">.</span><span class="pln">checkpoint</span><span class="pun">();</span><span class="pln">
    </span><span class="com">// 如果捕捉到错误，则执行 unmountComponent 后，再初始化挂载</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent</span><span class="pun">.</span><span class="pln">unmountComponent</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
    transaction</span><span class="pun">.</span><span class="pln">rollback</span><span class="pun">(</span><span class="pln">checkpoint</span><span class="pun">);</span><span class="pln">
    markup </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">performInitialMount</span><span class="pun">(</span><span class="pln">renderedElement</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln"> nativeContainerInfo</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln">
      context</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> markup</span><span class="pun">;</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
performInitialMount</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">renderedElement</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln"> nativeContainerInfo</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln">
  context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> inst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 如果存在 componentWillMount，则调用</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">componentWillMount</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    inst</span><span class="pun">.</span><span class="pln">componentWillMount</span><span class="pun">();</span><span class="pln">
    </span><span class="com">// componentWillMount 调用 setState 时，不会触发 re-render 而是自动提前合并</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingStateQueue</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      inst</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processPendingState</span><span class="pun">(</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">props</span><span class="pun">,</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">context</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果不是无状态组件，即可开始渲染</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">renderedElement </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    renderedElement </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderValidatedComponent</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedNodeType </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactNodeTypes</span><span class="pun">.</span><span class="pln">getType</span><span class="pun">(</span><span class="pln">renderedElement</span><span class="pun">);</span><span class="pln">
  </span><span class="com">// 得到 _currentElement 对应的 component 类实例</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instantiateReactComponent</span><span class="pun">(</span><span class="pln">
    renderedElement
  </span><span class="pun">);</span><span class="pln">
  </span><span class="com">// render 递归渲染</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> markup </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">mountComponent</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> nativeParent</span><span class="pun">,</span><span class="pln">
    nativeContainerInfo</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processChildContext</span><span class="pun">(</span><span class="pln">context</span><span class="pun">));</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> markup</span><span class="pun">;</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span></code></pre>
<p><strong>3. 阶段二：RECEIVE_PROPS</strong></p>
<p><code>updateComponent</code> 负责管理生命周期中的 <code>componentWillReceiveProps</code>、<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>render</code> 和 <code>componentDidUpdate</code>。</p>
<p>首先通过 <code>updateComponent</code> 更新组件，如果前后元素不一致，说明需要进行组件更新。</p>
<p>若存在 <code>componentWillReceiveProps</code>，则执行。如果此时在 <code>componentWillReceiveProps</code> 中调用 <code>setState</code>，是不会触发 <code>re-render</code> 的，而是会进行 state 合并。且在 <code>componentWillReceiveProps</code>、<code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code> 中也还是无法获取到更新后的 <code>this.state</code>，即此时访问的 <code>this.state</code> 仍然是未更新的数据，需要设置 <code>inst.state = nextState</code> 后才可以，因此只有在 <code>render</code> 和 <code>componentDidUpdate</code> 中才能获取到更新后的 <code>this.state</code>。</p>
<p>调用 <code>shouldComponentUpdate</code> 判断是否需要进行组件更新，如果存在 <code>componentWillUpdate</code>，则执行。</p>
<p><code>updateComponent</code> 本质上也是通过<strong>递归</strong>渲染内容的，由于递归的特性，父组件的 <code>componentWillUpdate</code> 是在其子组件的 <code>componentWillUpdate</code> 之前调用的，而父组件的 <code>componentDidUpdate</code> 也是在其子组件的 <code>componentDidUpdate</code> 之后调用的。</p>
<p>当渲染完成之后，若存在 <code>componentDidUpdate</code>，则触发，这就解释了 <code>componentWillReceiveProps</code>、<code>componentWillUpdate</code>、<code>render</code>、<code>componentDidUpdate</code> 它们之间的执行顺序。</p>
<blockquote>
<p><strong>注意</strong>　禁止在 <code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code> 中调用 <code>setState</code>，这会造成循环调用，直至耗光浏览器内存后崩溃。</p>
</blockquote>
<p><code>updateComponent</code> 的执行顺序如图 3-12 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.012.png" alt="" width="70%" style="width: 70%"></p>
<p><strong>图 3-12　<code>updateComponent</code> 的执行顺序</strong></p>
<p><code>updateComponent</code> 相关源码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// receiveComponent 是通过调用 updateComponent 进行组件更新的</span><span class="pln">
receiveComponent</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">nextElement</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> prevElement </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> prevContext </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingElement </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updateComponent</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> prevElement</span><span class="pun">,</span><span class="pln"> nextElement</span><span class="pun">,</span><span class="pln"> prevContext</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">);</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
updateComponent</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> prevParentElement</span><span class="pun">,</span><span class="pln"> nextParentElement</span><span class="pun">,</span><span class="pln"> prevUnmaskedContext</span><span class="pun">,</span><span class="pln"> nextUnmaskedContext</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> inst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> willReceive </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextContext</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextProps</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 上下文是否改变</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context </span><span class="pun">===</span><span class="pln"> nextUnmaskedContext</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    nextContext </span><span class="pun">=</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">context</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    nextContext </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processContext</span><span class="pun">(</span><span class="pln">nextUnmaskedContext</span><span class="pun">);</span><span class="pln">
    willReceive </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">prevParentElement </span><span class="pun">===</span><span class="pln"> nextParentElement</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 如果元素相同，则跳过元素类型检测</span><span class="pln">
    nextProps </span><span class="pun">=</span><span class="pln"> nextParentElement</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 检测元素类型</span><span class="pln">
    nextProps </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processProps</span><span class="pun">(</span><span class="pln">nextParentElement</span><span class="pun">.</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
    willReceive </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果存在 componentWillReceiveProps，则调用</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">willReceive </span><span class="pun">&amp;&amp;</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">componentWillReceiveProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    inst</span><span class="pun">.</span><span class="pln">componentWillReceiveProps</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 将新的 state 合并到更新队列中，此时 nextState 为最新的 state</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processPendingState</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">);</span><span class="pln">
  </span><span class="com">// 根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> shouldUpdate </span><span class="pun">=</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingForceUpdate </span><span class="pun">||</span><span class="pln">
    </span><span class="pun">!</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">shouldComponentUpdate </span><span class="pun">||</span><span class="pln">
    inst</span><span class="pun">.</span><span class="pln">shouldComponentUpdate</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">shouldUpdate</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 重置更新队列</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingForceUpdate </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// 即将更新 this.props、this.state 和 this.context</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_performComponentUpdate</span><span class="pun">(</span><span class="pln">nextParentElement</span><span class="pun">,</span><span class="pln"> nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln">
      nextUnmaskedContext</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 如果确定组件不更新，仍然要设置 props 和 state</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement </span><span class="pun">=</span><span class="pln"> nextParentElement</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context </span><span class="pun">=</span><span class="pln"> nextUnmaskedContext</span><span class="pun">;</span><span class="pln">
    inst</span><span class="pun">.</span><span class="pln">props </span><span class="pun">=</span><span class="pln"> nextProps</span><span class="pun">;</span><span class="pln">
    inst</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> nextState</span><span class="pun">;</span><span class="pln">
    inst</span><span class="pun">.</span><span class="pln">context </span><span class="pun">=</span><span class="pln"> nextContext</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="com">// 当确定组件需要更新时，则调用</span><span class="pln">
_performComponentUpdate</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">nextElement</span><span class="pun">,</span><span class="pln"> nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> unmaskedContext</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> inst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> hasComponentDidUpdate </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Boolean</span><span class="pun">(</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">componentDidUpdate</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> prevProps</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> prevState</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> prevContext</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 如果存在 componentDidUpdate，则将当前的 props、state 和 context 保存一份</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hasComponentDidUpdate</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    prevProps </span><span class="pun">=</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    prevState </span><span class="pun">=</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">
    prevContext </span><span class="pun">=</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">context</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果存在 componentWillUpdate，则调用</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">componentWillUpdate</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    inst</span><span class="pun">.</span><span class="pln">componentWillUpdate</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement </span><span class="pun">=</span><span class="pln"> nextElement</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context </span><span class="pun">=</span><span class="pln"> unmaskedContext</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 更新 this.props、this.state 和 this.context</span><span class="pln">
  inst</span><span class="pun">.</span><span class="pln">props </span><span class="pun">=</span><span class="pln"> nextProps</span><span class="pun">;</span><span class="pln">
  inst</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> nextState</span><span class="pun">;</span><span class="pln">
  inst</span><span class="pun">.</span><span class="pln">context </span><span class="pun">=</span><span class="pln"> nextContext</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 调用 render 渲染组件</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_updateRenderedComponent</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> unmaskedContext</span><span class="pun">);</span><span class="pln">
  </span><span class="com">// 当组件完成更新后，如果存在 componentDidUpdate，则调用</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">hasComponentDidUpdate</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    transaction</span><span class="pun">.</span><span class="pln">getReactMountReady</span><span class="pun">().</span><span class="pln">enqueue</span><span class="pun">(</span><span class="pln">
      inst</span><span class="pun">.</span><span class="pln">componentDidUpdate</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="pln">inst</span><span class="pun">,</span><span class="pln"> prevProps</span><span class="pun">,</span><span class="pln"> prevState</span><span class="pun">,</span><span class="pln"> prevContext</span><span class="pun">),</span><span class="pln">
      inst
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="com">// 调用 render 渲染组件</span><span class="pln">
_updateRenderedComponent</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> prevComponentInstance </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> prevRenderedElement </span><span class="pun">=</span><span class="pln"> prevComponentInstance</span><span class="pun">.</span><span class="pln">_currentElement</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextRenderedElement </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderValidatedComponent</span><span class="pun">();</span><span class="pln">
  </span><span class="com">// 如果需要更新，则调用 ReactReconciler.receiveComponent 继续更新组件</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">shouldUpdateReactComponent</span><span class="pun">(</span><span class="pln">prevRenderedElement</span><span class="pun">,</span><span class="pln"> nextRenderedElement</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">receiveComponent</span><span class="pun">(</span><span class="pln">prevComponentInstance</span><span class="pun">,</span><span class="pln"> nextRenderedElement</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processChildContext</span><span class="pun">(</span><span class="pln">context</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 如果不需要更新，则渲染组件</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> oldNativeNode </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">getNativeNode</span><span class="pun">(</span><span class="pln">prevComponentInstance</span><span class="pun">);</span><span class="pln">
    </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">unmountComponent</span><span class="pun">(</span><span class="pln">prevComponentInstance</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedNodeType </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactNodeTypes</span><span class="pun">.</span><span class="pln">getType</span><span class="pun">(</span><span class="pln">nextRenderedElement</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// 得到 nextRenderedElement 对应的 component 类实例</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instantiateReactComponent</span><span class="pun">(</span><span class="pln">
      nextRenderedElement
    </span><span class="pun">);</span><span class="pln">
    </span><span class="com">// 使用 render 递归渲染</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> nextMarkup </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">mountComponent</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeParent</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeContainerInfo</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processChildContext</span><span class="pun">(</span><span class="pln">context</span><span class="pun">));</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_replaceNodeWithMarkup</span><span class="pun">(</span><span class="pln">oldNativeNode</span><span class="pun">,</span><span class="pln"> nextMarkup</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><strong>4. 阶段三：UNMOUNTING</strong></p>
<p><code>unmountComponent</code> 负责管理生命周期中的 <code>componentWillUnmount</code>。</p>
<p>如果存在 <code>componentWillUnmount</code>，则执行并重置所有相关参数、更新队列以及更新状态，如果此时在 <code>componentWillUnmount</code> 中调用 <code>setState</code>，是不会触发 <code>re-render</code> 的，这是因为所有更新队列和更新状态都被重置为 <code>null</code>，并清除了公共类，完成了组件卸载操作。<code>unmountComponent</code> 的代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">unmountComponent</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">safely</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> inst </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 如果存在 componentWillUnmount，则调用</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">componentWillUnmount</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">safely</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">getName</span><span class="pun">()</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">'.componentWillUnmount()'</span><span class="pun">;</span><span class="pln">
      </span><span class="typ">ReactErrorUtils</span><span class="pun">.</span><span class="pln">invokeGuardedCallback</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> inst</span><span class="pun">.</span><span class="pln">componentWillUnmount</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="pln">inst</span><span class="pun">));</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      inst</span><span class="pun">.</span><span class="pln">componentWillUnmount</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果组件已经渲染，则对组件进行 unmountComponent 操作</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">unmountComponent</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent</span><span class="pun">,</span><span class="pln"> safely</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedNodeType </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedComponent </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_instance </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 重置相关参数、更新队列以及更新状态</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingStateQueue </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingReplaceState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingForceUpdate </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingCallbacks </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingElement </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_rootNodeID </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_topLevelWrapper </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 清除公共类</span><span class="pln">
  </span><span class="typ">ReactInstanceMap</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="pln">inst</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>至此，我们跟随着 React 源码的脚步完整地了解其生命周期的执行过程，你是否已经对 React 生命周期有了更深刻的理解了呢？</p>
<p>生命周期和 state 状态让 React 组件无比灵活与强大，同时也使得组件变得复杂而难以维护。在实际的项目开发中，我们经常需要编写一些自身没有状态，只是从父组件接受 props，并根据这些属性进行渲染的简单组件，这不仅让组件的开发变得简单、高效，也便于对状态进行统一管理。因此，在 React 开发中，一个很重要的原则就是让组件尽可能是无状态的。</p>
<p>当然，React 官方也是鼓励这一原则的。在 React 0.14 之后，便推出了无状态组件，大大增强了 React 组件编写的便捷性，也提升了整体的渲染性能。</p>
<h3><strong>3.3.3　无状态组件</strong></h3>
<p>我们在 1.3 节中提到过无状态组件。无状态组件只是一个 <code>render</code> 方法，并没有组件类的实例化过程，也没有实例返回。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">HelloWorld</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="str">&lt;div&gt;</span><span class="pun">{</span><span class="pln">props</span><span class="pun">.</span><span class="pln">name</span><span class="pun">}&lt;/</span><span class="pln">div</span><span class="pun">&gt;;</span><span class="pln">
</span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(&lt;</span><span class="typ">HelloWorld</span><span class="pln"> name</span><span class="pun">=</span><span class="str">"Hello World!"</span><span class="pln"> </span><span class="pun">/&gt;,</span><span class="pln"> </span><span class="typ">App</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p><code>render</code> 函数和 <code>shouldConstruct</code> 函数的代码如下（源码路径：/v15.0.0/src/renderers/shared/reconciler/ReactCompositeComponent.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 无状态组件只有一个 render 函数</span><span class="pln">
</span><span class="typ">StatelessComponent</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">render </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactInstanceMap</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">).</span><span class="pln">_currentElement</span><span class="pun">.</span><span class="pln">type</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// 没有 state 状态</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> element </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">context</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updater</span><span class="pun">);</span><span class="pln">
  warnIfInvalidElement</span><span class="pun">(</span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> element</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> element</span><span class="pun">;</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> shouldConstruct</span><span class="pun">(</span><span class="typ">Component</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">.</span><span class="pln">prototype </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">isReactComponent</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>无状态组件没有状态，没有生命周期，只是简单地接受 props 渲染生成 DOM 结构，是一个纯粹为渲染而生的组件。由于无状态组件有简单、便捷、高效等诸多优点，所以如果可能的话，请尽量使用无状态组件。</p>
<p>最后用一张图再次归纳一下生命周期，如图 3-13 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.013.png" alt="{%}"></p>
<p><strong>图 3-13　生命周期全局图</strong></p>
<h2><strong>3.4　解密<code>setState</code>机制</strong></h2>
<p>state 是 React 中重要的概念。第 1 章中提到过，React 是通过管理状态来实现对组件的管理。那么，React 是如何控制组件的状态的，又是如何利用状态来管理组件的呢？</p>
<p>众所周知，React 通过 <code>this.state</code> 来访问 state，通过 <code>this.setState()</code> 方法来更新 state。当<code>this.setState()</code> 被调用的时候，React 会重新调用 <code>render</code> 方法来重新渲染 UI。</p>
<p>想必 <code>setState</code> 已经是我们再熟悉不过的 API，然而你真的了解它吗？本节将为我们解密 <code>setState</code> 的更新机制。</p>
<h3><strong>3.4.1　<code>setState</code>异步更新</strong></h3>
<p>React 初学者常会写出 <code>this.state.value = 1</code> 这样的代码，这是完全错误的写法。</p>
<blockquote>
<p><strong>注意</strong>　绝对不要直接修改 <code>this.state</code>，这不仅是一种低效的做法，而且很有可能会被之后的操作替换。</p>
</blockquote>
<p><code>setState</code> 通过一个队列机制实现 state 更新。当执行 <code>setState</code> 时，会将需要更新的 state 合并后放入状态队列，而不会立刻更新 <code>this.state</code>，队列机制可以高效地批量更新 state。如果不通过 <code>setState</code> 而直接修改 <code>this.state</code> 的值，那么该 state 将不会被放入状态队列中，当下次调用 <code>setState</code> 并对状态队列进行合并时，将会忽略之前直接被修改的 state，而造成无法预知的错误。因此，应该使用 <code>setState</code> 方法来更新 state，同时 React 也正是利用状态队列机制实现了 <code>setState</code> 的异步更新，避免频繁地重复更新 state。相关代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 将新的 state 合并到状态更新队列中</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> nextState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_processPendingState</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">);</span><span class="pln">
</span><span class="com">// 根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> shouldUpdate </span><span class="pun">=</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingForceUpdate </span><span class="pun">||</span><span class="pln">
  </span><span class="pun">!</span><span class="pln">inst</span><span class="pun">.</span><span class="pln">shouldComponentUpdate </span><span class="pun">||</span><span class="pln">
  inst</span><span class="pun">.</span><span class="pln">shouldComponentUpdate</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">,</span><span class="pln"> nextContext</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<h3><strong>3.4.2　<code>setState</code> 循环调用风险</strong></h3>
<p>当调用 <code>setState</code> 时，实际上会执行 <code>enqueueSetState</code> 方法，并对 <code>partialState</code> 以及<code>_pendingStateQueue</code> 更新队列进行合并操作，最终通过 <code>enqueueUpdate</code> 执行 <code>state</code> 更新。</p>
<p>而 <code>performUpdateIfNecessary</code> 方法会获取 <code>_pendingElement</code>、<code>_pendingStateQueue</code>、<code>_pendingForceUpdate</code>，并调用 <code>receiveComponent</code> 和 <code>updateComponent</code> 方法进行组件更新。</p>
<p>如果在 <code>shouldComponentUpdate</code> 或 <code>componentWillUpdate</code> 方法中调用 <code>setState</code>，此时 <code>this._pendingStateQueue != null</code>，则 <code>performUpdateIfNecessary</code> 方法就会调用 <code>updateComponent</code> 方法进行组件更新，但 <code>updateComponent</code> 方法又会调用 <code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code> 方法，因此造成循环调用，使得浏览器内存占满后崩溃，如图 3-14 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.014.png" alt="" width="80%" style="width: 80%"></p>
<p><strong>图 3-14　循环调用</strong></p>
<p>接着我们来看 <code>setState</code> 的源码：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 更新 state</span><span class="pln">
</span><span class="typ">ReactComponent</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">.</span><span class="pln">setState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">partialState</span><span class="pun">,</span><span class="pln"> callback</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updater</span><span class="pun">.</span><span class="pln">enqueueSetState</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> partialState</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">callback</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updater</span><span class="pun">.</span><span class="pln">enqueueCallback</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> callback</span><span class="pun">,</span><span class="pln"> </span><span class="str">'setState'</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
enqueueSetState</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">publicInstance</span><span class="pun">,</span><span class="pln"> partialState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> internalInstance </span><span class="pun">=</span><span class="pln"> getInternalInstanceReadyForUpdate</span><span class="pun">(</span><span class="pln">
    publicInstance</span><span class="pun">,</span><span class="pln">
    </span><span class="str">'setState'</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">internalInstance</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 更新队列合并操作</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> queue </span><span class="pun">=</span><span class="pln"> internalInstance</span><span class="pun">.</span><span class="pln">_pendingStateQueue </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">internalInstance</span><span class="pun">.</span><span class="pln">_pendingStateQueue </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[]);</span><span class="pln">
  queue</span><span class="pun">.</span><span class="pln">push</span><span class="pun">(</span><span class="pln">partialState</span><span class="pun">);</span><span class="pln">
  enqueueUpdate</span><span class="pun">(</span><span class="pln">internalInstance</span><span class="pun">);</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="com">// 如果存在 _pendingElement、_pendingStateQueue和_pendingForceUpdate，则更新组件</span><span class="pln">
performUpdateIfNecessary</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingElement </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">receiveComponent</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingElement</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingStateQueue </span><span class="pun">!==</span><span class="pln"> </span><span class="kwd">null</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_pendingForceUpdate</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updateComponent</span><span class="pun">(</span><span class="pln">transaction</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_currentElement</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_context</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<h3><strong>3.4.3　<code>setState</code>调用栈</strong></h3>
<p>既然 <code>setState</code> 最终是通过 <code>enqueueUpdate</code> 执行 state 更新，那么 <code>enqueueUpdate</code> 到底是如何更新 state 的呢？</p>
<p>首先，看看下面这个问题，你是否能够正确回答呢？</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Example</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      val</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">val</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val</span><span class="pun">);</span><span class="pln">    </span><span class="com">// 第 1 次输出</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">val</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val</span><span class="pun">);</span><span class="pln">    </span><span class="com">// 第 2 次输出</span><span class="pln">
    setTimeout</span><span class="pun">(()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">val</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
      console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val</span><span class="pun">);</span><span class="pln">  </span><span class="com">// 第 3 次输出</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">val</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
      console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val</span><span class="pun">);</span><span class="pln">  </span><span class="com">// 第 4 次输出</span><span class="pln">
    </span><span class="pun">},</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>上述代码中， 4 次 <code>console.log</code> 打印出来的 <code>val</code> 分别是：0、0、2、3。</p>
<p>假如结果与你心中的答案不完全相同，那么你应该会感兴趣 <code>enqueueUpdate</code> 到底做了什么？</p>
<p>图 3-15 是一个简化的 <code>setState</code> 调用栈，注意其中核心的状态判断。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.015.png" alt="{%}"></p>
<p><strong>图 3-15　<code>setState</code> 简化调用栈</strong></p>
<p><code>enqueueUpdate</code> 的代码如下（源码路径：/v15.0.0/src/ renderers/shared/reconciler/ReactUpdates.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> enqueueUpdate</span><span class="pun">(</span><span class="pln">component</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  ensureInjected</span><span class="pun">();</span><span class="pln">
  </span><span class="com">// 如果不处于批量更新模式</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">batchingStrategy</span><span class="pun">.</span><span class="pln">isBatchingUpdates</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    batchingStrategy</span><span class="pun">.</span><span class="pln">batchedUpdates</span><span class="pun">(</span><span class="pln">enqueueUpdate</span><span class="pun">,</span><span class="pln"> component</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果处于批量更新模式，则将该组件保存在 dirtyComponents 中</span><span class="pln">
  dirtyComponents</span><span class="pun">.</span><span class="pln">push</span><span class="pun">(</span><span class="pln">component</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>如果 <code>isBatchingUpdates</code> 为 <code>true</code>，则对所有队列中的更新执行 <code>batchedUpdates</code> 方法，否则只把当前组件（即调用了 <code>setState</code> 的组件）放入 <code>dirtyComponents</code> 数组中。例子中 4 次 <code>setState</code> 调用的表现之所以不同，这里逻辑判断起了关键作用。</p>
<p>那么 <code>batchingStrategy</code> 究竟做什么呢？其实它只是一个简单的对象，定义了一个 <code>isBatchingUpdates</code> 的布尔值，以及 <code>batchedUpdates</code> 方法（源码路径：/v15.0.0/src/renderers/shared/reconciler/ReactDefaultBatchingStrategy.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">var</span><span class="pln"> </span><span class="typ">ReactDefaultBatchingStrategy</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  isBatchingUpdates</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
  batchedUpdates</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">callback</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">,</span><span class="pln"> c</span><span class="pun">,</span><span class="pln"> d</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> alreadyBatchingUpdates </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactDefaultBatchingStrategy</span><span class="pun">.</span><span class="pln">isBatchingUpdates</span><span class="pun">;</span><span class="pln">
    </span><span class="typ">ReactDefaultBatchingStrategy</span><span class="pun">.</span><span class="pln">isBatchingUpdates </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">alreadyBatchingUpdates</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      callback</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">,</span><span class="pln"> c</span><span class="pun">,</span><span class="pln"> d</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      transaction</span><span class="pun">.</span><span class="pln">perform</span><span class="pun">(</span><span class="pln">callback</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">,</span><span class="pln"> c</span><span class="pun">,</span><span class="pln"> d</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>值得注意的是，<code>batchedUpdates</code> 方法中有一个 <code>transaction.perform</code> 调用，这是本章后续要介绍的核心概念——事务（transaction）。</p>
<h3><strong>3.4.4　初识事务</strong></h3>
<p>事务源码中有一幅图，形象地解释了它的作用，如图 3-16 所示（本节的源码路径：/v15.0.0/src/shared/utils/Transaction.js）。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.016.png" alt="{%}"></p>
<p><strong>图 3-16　ReactCompositeComponent 流程图</strong></p>
<p>事务就是将需要执行的方法使用 wrapper 封装起来，再通过事务提供的 <code>perform</code> 方法执行。而在 <code>perform</code> 之前，先执行所有 wrapper 中的 <code>initialize</code> 方法，执行完 <code>perform</code> 之后（即执行 <code>method</code> 方法后）再执行所有的 <code>close</code> 方法。一组 <code>initialize</code> 及 <code>close</code> 方法称为一个 wrapper。从图3-16中可以看出，事务支持多个 wrapper 叠加。</p>
<p>到实现上，事务提供了一个 mixin 方法供其他模块实现自己需要的事务。而要使用事务的模块，除了需要把 mixin 混入自己的事务实现中外，还要额外实现一个抽象的 <code>getTransactionWrappers</code> 接口。这个接口用来获取所有需要封装的前置方法（<code>initialize</code>）和收尾方法（<code>close</code>），因此它需要返回一个数组的对象，每个对象分别有 key 为 <code>initialize</code> 和 <code>close</code> 的方法。</p>
<p>下面是一个简单使用事务的例子：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">var</span><span class="pln"> </span><span class="typ">Transaction</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">require</span><span class="pun">(</span><span class="str">'./Transaction'</span><span class="pun">);</span><span class="pln">
</span><span class="com">// 我们自己定义的事务</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> </span><span class="typ">MyTransaction</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// ...</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span><span class="typ">Object</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">(</span><span class="typ">MyTransaction</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Transaction</span><span class="pun">.</span><span class="typ">Mixin</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  getTransactionWrappers</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">[{</span><span class="pln">
      initialize</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'before method perform'</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">},</span><span class="pln">
      close</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'after method perform'</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}];</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> transaction </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">MyTransaction</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> testMethod </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'test'</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
transaction</span><span class="pun">.</span><span class="pln">perform</span><span class="pun">(</span><span class="pln">testMethod</span><span class="pun">);</span><span class="pln">
</span><span class="com">// 打印的结果如下：</span><span class="pln">
</span><span class="com">// before method perform</span><span class="pln">
</span><span class="com">// test</span><span class="pln">
</span><span class="com">// after method perform</span><span class="pln">
</span></code></pre>
<p>当然，在 React 中还做了异常处理等工作，这里就不详细展开了。如果你有兴趣，可以继续翻看源码。</p>
<h3><strong>3.4.5　解密<code>setState</code></strong></h3>
<p>说了这么多，事务到底是怎么导致前面所述的 <code>setState</code> 的各种不同表现的呢？</p>
<p>这里我们先要了解事务跟 <code>setState</code> 的不同表现有什么关系。首先，我们把4次 <code>setState</code> 简单归类，前两次属于一类，因为它们在同一次调用栈中执行，<code>setTimeout</code> 中的两次 <code>setState</code> 属于另一类，原因同上。下面我们分别看看这两类 <code>setState</code> 的调用栈，如图 3-17 和图 3-18 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.017.png" alt="{%}"></p>
<p><strong>图 3-17　<code>componentDidMount</code>中<code>setState</code>的调用栈</strong></p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.018.png" alt="{%}"></p>
<p><strong>图 3-18　<code>setTimeout</code> 中 <code>setState</code> 的调用栈</strong></p>
<p>很明显，在 <code>componentDidMount</code> 中直接调用的两次 <code>setState</code>，其调用栈更加复杂；而<code>setTimeout</code> 中调用的两次 <code>setState</code>，其调用栈则简单很多。下面重点看看第一类 <code>setState</code> 的调用栈，有没有发现什么？没错，就是 <code>batchedUpdates</code> 方法，原来早在 <code>setState</code> 调用前，已经处于 <code>batchedUpdates</code> 执行的事务中了。</p>
<p>那这次 <code>batchedUpdate</code> 方法，又是谁调用的呢？让我们往前再追溯一层，原来是 ReactMount.js中的 <code>_renderNewRootComponent</code> 方法。也就是说，整个将 React 组件渲染到 DOM 中的过程就处于一个大的事务中。</p>
<p>接下来的解释就顺理成章了，因为在 <code>componentDidMount</code> 中调用 <code>setState</code> 时，<code>batchingStrategy</code>的 <code>isBatchingUpdates</code> 已经被设为 <code>true</code>，所以两次 <code>setState</code> 的结果并没有立即生效，而是被放进了 <code>dirtyComponents</code> 中。这也解释了两次打印 <code>this.state.val</code> 都是 0 的原因，因为新的 state 还没有被应用到组件中。</p>
<p>再反观<code>setTimeout</code>中的两次<code>setState</code>，因为没有前置的<code>batchedUpdate</code>调用，所以<code>batchingStrategy</code> 的 <code>isBatchingUpdates</code> 标志位是 <code>false</code>，也就导致了新的 state 马上生效，没有走到 <code>dirtyComponents</code> 分支。也就是说，<code>setTimeout</code> 中第一次执行 <code>setState</code> 时，<code>this.state.val</code>为 1，而 <code>setState</code> 完成后打印时 <code>this.state.val</code> 变成了 2。第二次的 <code>setState</code> 同理。</p>
<p>前面介绍事务时，也提到了其在 React 源码中的多处应用，像 <code>initialize</code>、<code>perform</code>、<code>close</code>、<code>closeAll</code>、<code>notifyAll</code> 等方法出现在调用栈中，都说明当前处于一个事务中。</p>
<p>既然事务这么有用，我们写应用代码时能使用它吗？很可惜，答案是不能。尽管 React 不建议我们直接使用事务，但在 React 15.0 之前的版本中还是为开发者提供了 <code>batchedUpdates</code> 方法，它可以解决针对一开始例子中 <code>setTimeout</code> 里的两次 <code>setState</code> 导致两次 <code>render</code> 的情况：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> unstable_batchedUpdates </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
unstable_batchedUpdates</span><span class="pun">(()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">(</span><span class="pln">val</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">(</span><span class="pln">val</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">val </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>在 React 15.0 以及之后版本中，已经彻底将 <code>batchedUpdates</code> 这个 API 移除了，因此不再建议开发者使用它。</p>
<h2><strong>3.5　diff 算法</strong></h2>
<p>diff 作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础和性能保障，同时也是 React 源码中最神秘、最不可思议的部分。本节依然从源码入手，深入剖析 diff 的不可思议之处。</p>
<p>React 中最值得称道的部分莫过于 Virtual DOM 模型与 diff 的完美结合，特别是其高效的 diff 算法，可以让用户无需顾忌性能问题而“任性自由”地刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理。因为 diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行原生 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。因此，Virtual DOM 模型与 diff 是保证 React 性能口碑的幕后推手。</p>
<p>diff 算法也并非其首创。正是因为该算法的普适度高，就更应该认可 React 针对 diff 算法优化所做的努力与贡献，这更能体现 React 创作者们的魅力与智慧！</p>
<h3><strong>3.5.1　传统 diff 算法</strong></h3>
<p>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法<span class="注释编号">1</span>通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 <em>O</em>(<em>n</em><sup>3</sup>)，其中 <em>n</em> 是树中节点的总数。<em>O</em>(<em>n</em><sup>3</sup>) 到底有多可怕呢？这意味着如果要展示 1000 个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了。如今的 CPU 每秒钟能执行大约 30 亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。</p>
<p class="注释内容"><span class="注释编号下">1</span>A Survey on Tree Edit Distance and Related Problems，详见 <a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank">http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf</a>。</p>
<p>因此，如果 React 只是单纯地引入 diff 算法而没有任何的优化改进，那么其效率远远无法满足前端渲染所要求的性能。如果想要将 diff 思想引入 Virtual DOM，就要设计一种稳定、高效的 diff 算法，这个 React 做到了！</p>
<p>那么，diff 到底是如何实现的呢？</p>
<h3><strong>3.5.2　详解 diff</strong></h3>
<p>React 将 Virtual DOM 树转换成 actual DOM 树的最少操作的过程称为调和（reconciliation）。diff 算法便是调和的具体实现。那么这个过程是怎么实现的呢？</p>
<p>React 通过制定大胆的策略，将 <em>O</em>(<em>n</em><sup>3</sup>) 复杂度的问题转换成 <em>O</em>(<em>n</em>) 复杂度的问题。</p>
<p><strong>1. diff 策略</strong></p>
<p>下面介绍 React diff 算法的 3 个策略。</p>
<ul>
<li><p>策略一：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</p>
</li>
<li><p>策略二：拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</p>
</li>
<li><p>策略三：对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</p>
</li>
</ul>
<p>基于以上策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。事实也证明这 3 个前提策略是合理且准确的，它保证了整体界面构建的性能。</p>
<p><strong>2. tree diff</strong></p>
<p>基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。</p>
<p>既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 <code>updateDepth</code> 对 Virtual DOM 树进行层级控制，只会对相同层级的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p>
<p><code>updateChildren</code> 方法对应的源码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">updateChildren</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">nextNestedChildrenElements</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  updateDepth</span><span class="pun">++;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> errorThrown </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_updateChildren</span><span class="pun">(</span><span class="pln">nextNestedChildrenElements</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">);</span><span class="pln">
    errorThrown </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">finally</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    updateDepth</span><span class="pun">--;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">updateDepth</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">errorThrown</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        clearQueue</span><span class="pun">();</span><span class="pln">
      </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        processQueue</span><span class="pun">();</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><strong>你可能存在这样的疑问：如果出现了 DOM 节点跨层级的移动操作，diff 会有怎样的表现呢？</strong>我们不妨试验一番。</p>
<p>如图 3-19 所示，A 节点（包括其子节点）整个被移动到 D 节点下，由于 React 只会简单地考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，diff 的执行情况：create A → create B → create C → delete A。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.019.png" alt="" width="90%" style="width: 90%"></p>
<p><strong>图 3-19　DOM 层级变换</strong></p>
<p>由此可以发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的整个树被重新创建。这是一种影响 React 性能的操作，因此<strong>官方建议不要进行 DOM 节点跨层级的操作</strong>。</p>
<blockquote>
<p><strong>注意</strong>　在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真正地移除或添加 DOM 节点。</p>
</blockquote>
<p><strong>3. component diff</strong></p>
<p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是非常简洁、高效的。</p>
<ul>
<li><p>如果是同一类型的组件，按照原策略继续比较 Virtual DOM 树即可。</p>
</li>
<li><p>如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。</p>
</li>
<li><p>对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切知道这点，那么就可以节省大量的 diff 运算时间。因此，React 允许用户通过 <code>shouldComponentUpdate()</code> 来判断该组件是否需要进行 diff 算法分析。</p>
</li>
</ul>
<p>如图 3-20 所示，当组件 D 变为组件 G 时，即使这两个组件结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除组件 D，重新创建组件 G 及其子节点。虽然当两个组件是不同类型但结构相似时，diff 会影响性能，但正如 React 官方博客所言：不同类型的组件很少存在相似 DOM 树的情况，因此这种极端因素很难在实际开发过程中造成重大的影响。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.020.png" alt="{%}"></p>
<p><strong>图 3-20　component diff</strong></p>
<p><strong>4. element diff</strong></p>
<p>当节点处于同一层级时，diff 提供了 3 种节点操作，分别为 <code>INSERT_MARKUP</code>（插入）、<code>MOVE_EXISTING</code>（移动）和 <code>REMOVE_NODE</code>（删除）。</p>
<ul>
<li><p><strong><code>INSERT_MARKUP</code></strong>：新的组件类型不在旧集合里，即全新的节点，需要对新节点执行插入操作。</p>
</li>
<li><p><strong><code>MOVE_EXISTING</code></strong>：旧集合中有新组件类型，且 element 是可更新的类型，<code>generateComponentChildren</code> 已调用 <code>receiveComponent</code>，这种情况下 <code>prevChild=nextChild</code>，就需要做移动操作，可以复用以前的 DOM 节点。</p>
</li>
<li><p><strong><code>REMOVE_NODE</code></strong>：旧组件类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者旧组件不在新集合里的，也需要执行删除操作。</p>
</li>
</ul>
<p>相关代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> makeInsertMarkup</span><span class="pun">(</span><span class="pln">markup</span><span class="pun">,</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln"> toIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ReactMultiChildUpdateTypes</span><span class="pun">.</span><span class="pln">INSERT_MARKUP</span><span class="pun">,</span><span class="pln">
    content</span><span class="pun">:</span><span class="pln"> markup</span><span class="pun">,</span><span class="pln">
    fromIndex</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
    fromNode</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
    toIndex</span><span class="pun">:</span><span class="pln"> toIndex</span><span class="pun">,</span><span class="pln">
    afterNode</span><span class="pun">:</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> makeMove</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln"> toIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ReactMultiChildUpdateTypes</span><span class="pun">.</span><span class="pln">MOVE_EXISTING</span><span class="pun">,</span><span class="pln">
    content</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
    fromIndex</span><span class="pun">:</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">_mountIndex</span><span class="pun">,</span><span class="pln">
    fromNode</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">getNativeNode</span><span class="pun">(</span><span class="pln">child</span><span class="pun">),</span><span class="pln">
    toIndex</span><span class="pun">:</span><span class="pln"> toIndex</span><span class="pun">,</span><span class="pln">
    afterNode</span><span class="pun">:</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> makeRemove</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> node</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ReactMultiChildUpdateTypes</span><span class="pun">.</span><span class="pln">REMOVE_NODE</span><span class="pun">,</span><span class="pln">
    content</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
    fromIndex</span><span class="pun">:</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">_mountIndex</span><span class="pun">,</span><span class="pln">
    fromNode</span><span class="pun">:</span><span class="pln"> node</span><span class="pun">,</span><span class="pln">
    toIndex</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
    afterNode</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>如图 3-21 所示，旧集合中包含节点A、B、C 和 D，更新后的新集合中包含节点 B、A、D 和 C，此时新旧集合进行 diff 差异化对比，发现 <code>B != A</code>，则创建并插入 B 至新集合，删除旧集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.021.png" alt="" width="85%" style="width: 85%"></p>
<p><strong>图 3-21　节点 diff</strong></p>
<p>React 发现这类操作烦琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。</p>
<p>针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</p>
<p>新旧集合所包含的节点如图 3-22 所示，进行 diff 差异化对比后，通过 key 发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作即可。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.022.png" alt="" width="85%" style="width: 85%"></p>
<p><strong>图 3-22　对节点进行 diff 差异化对比</strong></p>
<p>那么，如此高效的 diff 到底是如何运作的呢？让我们通过源码详细分析一下。</p>
<p>首先，对新集合中的节点进行循环遍历 <code>for (name in nextChildren)</code>，通过唯一的 key 判断新旧集合中是否存在相同的节点 <code>if (prevChild === nextChild)</code>，如果存在相同节点，则进行移动操作，但在移动前需要将当前节点在旧集合中的位置与 <code>lastIndex</code> 进行比较 <code>if (child._mountIndex &lt; lastIndex)</code>，否则不执行该操作。这是一种顺序优化手段，<code>lastIndex</code> 一直在更新，表示访问过的节点在旧集合中最右的位置（即最大的位置）。如果新集合中当前访问的节点比 <code>lastIndex</code> 大，说明当前访问节点在旧集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作。只有当访问的节点比 <code>lastIndex</code> 小时，才需要进行移动操作。</p>
<p>以图 3-22 为例，下面更为清晰直观地描述 diff 的差异化对比过程。</p>
<ul>
<li><p>从新集合中取得 B，然后判断旧集合中是否存在相同节点 B，此时发现存在节点 B，接着通过对比节点位置判断是否进行移动操作。B 在旧集合中的位置 <code>B._mountIndex = 1</code>，此时 <code>lastIndex = 0</code>，不满足 <code>child._mountIndex &lt; lastIndex</code> 的条件，因此不对 B 进行移动操作。更新 <code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，其中 <code>prevChild._mountIndex</code> 表示B在旧集合中的位置，则<code>lastIndex = 1</code>，并将B的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>B._mountIndex = 0</code>，<code>nextIndex++</code> 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 A，然后判断旧集合中是否存在相同节点 A，此时发现存在节点 A，接着通过对比节点位置判断是否进行移动操作。A 在旧集合中的位置 <code>A._mountIndex = 0</code>，此时 <code>lastIndex = 1</code>，满足 <code>child._mountIndex &lt; lastIndex</code> 的条件，因此对 A 进行移动操作 <code>enqueueMove(this, child._mountIndex, toIndex)</code>，其中 <code>toIndex</code> 其实就是 <code>nextIndex</code>，表示 A 需要移动到的位置。更新 <code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，则<code>lastIndex = 1</code>，并将 A 的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>A._mountIndex = 1</code>，<code>nextIndex++</code> 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 D，然后判断旧集合中是否存在相同节点 D，此时发现存在节点 D，接着通过对比节点位置判断是否进行移动操作。D 在旧集合中的位置 <code>D._mountIndex = 3</code>，此时 <code>lastIndex = 1</code>，不满足 <code>child._mountIndex &lt; lastIndex</code> 的条件，因此不对 D 进行移动操作。更新 <code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，则 <code>lastIndex = 3</code>，并将 D 的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>D._mountIndex = 2</code>，<code>nextIndex++</code> 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 C，然后判断旧集合中是否存在相同节点 C，此时发现存在节点 C，接着通过对比节点位置判断是否进行移动操作。C 在旧集合中的位置 <code>C._mountIndex = 2</code>，此时 <code>lastIndex = 3</code>，满足 <code>child._mountIndex &lt; lastIndex</code>的条件，因此对 C 进行移动操作 <code>enqueueMove(this, child._mountIndex, toIndex)</code>。更新<code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，则 <code>lastIndex = 3</code>，并将 C 的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>A._mountIndex = 3</code>，<code>nextIndex++</code> 进入下一个节点的判断。由于 C 已经是最后一个节点，因此 diff 操作到此完成。</p>
</li>
</ul>
<p>上面主要分析新旧集合中存在相同节点但位置不同时，对节点进行位置移动的情况。如果新集合中有新加入的节点且旧集合存在需要删除的节点，那么 diff 又是如何对比运作的呢？</p>
<p>下面以图 3-23 为例进行介绍。</p>
<ul>
<li><p>从新集合中取得B，然后判断旧集合中存在是否相同节点 B，可以发现存在节点 B。由于 B 在旧集合中的位置 <code>B._mountIndex = 1</code>，此时 <code>lastIndex = 0</code>，因此不对 B 进行移动操作。更新<code>lastIndex = 1</code>，并将 B 的位置更新为新集合中的位置 <code>B._mountIndex = 0</code>，<code>nextIndex++</code>进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 E，然后判断旧集合中是否存在相同节点 E，可以发现不存在，此时可以创建新节点 E。更新 <code>lastIndex = 1</code>，并将 E 的位置更新为新集合中的位置，<code>nextIndex++</code> 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 C，然后判断旧集合中是否存在相同节点 C，此时可以发现存在节点 C。由于 C 在旧集合中的位置 <code>C._mountIndex = 2</code>，<code>lastIndex = 1</code>，此时 <code>C._mountIndex &gt; lastIndex</code>，因此不对 C 进行移动操作。更新 <code>lastIndex = 2</code>，并将 C 的位置更新为新集合中的位置，<code>nextIndex++</code> 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 A，然后判断旧集合中是否存在相同节点 A，此时发现存在节点 A。由于 A 在旧集合中的位置 <code>A._mountIndex = 0</code>，<code>lastIndex = 2</code>，此时 <code>A._mountIndex &lt; lastIndex</code>，因此对 A 进行移动操作。更新 <code>lastIndex = 2</code>，并将 A 的位置更新为新集合中的位置，<code>nextIndex++</code> 进入下一个节点的判断。</p>
</li>
<li><p>当完成新集合中所有节点的差异化对比后，还需要对旧集合进行循环遍历，判断是否存在新集合中没有但旧集合中仍存在的节点，此时发现存在这样的节点 D，因此删除节点 D，到此 diff 操作全部完成。</p>
</li>
</ul>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.023.png" alt="" width="85%" style="width: 85%"></p>
<p><strong>图 3-23　创建、移动、删除节点</strong></p>
<p>相关代码如下（源码路径：/v15.0.0/src/renderers/shared/reconciler/ReactMultiChild.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">_updateChildren</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">nextNestedChildrenElements</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> prevChildren </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedChildren</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> removedNodes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextChildren </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_reconcilerUpdateChildren</span><span class="pun">(</span><span class="pln">prevChildren</span><span class="pun">,</span><span class="pln"> nextNestedChildrenElements</span><span class="pun">,</span><span class="pln"> removedNodes</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">);</span><span class="pln">
  </span><span class="com">// 如果不存在 prevChildren 和 nextChildren，则不做 diff 处理</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">nextChildren </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">prevChildren</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> updates </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> name</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// lastIndex 是 prevChildren 中最后的索引，nextIndex 是 nextChildren 中每个节点的索引</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> lastIndex </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> nextIndex </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> lastPlacedNode </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">name </span><span class="kwd">in</span><span class="pln"> nextChildren</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">nextChildren</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">name</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> prevChild </span><span class="pun">=</span><span class="pln"> prevChildren </span><span class="pun">&amp;&amp;</span><span class="pln"> prevChildren</span><span class="pun">[</span><span class="pln">name</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> nextChild </span><span class="pun">=</span><span class="pln"> nextChildren</span><span class="pun">[</span><span class="pln">name</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">prevChild </span><span class="pun">===</span><span class="pln"> nextChild</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 移动节点</span><span class="pln">
      updates </span><span class="pun">=</span><span class="pln"> enqueue</span><span class="pun">(</span><span class="pln">
        updates</span><span class="pun">,</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">moveChild</span><span class="pun">(</span><span class="pln">prevChild</span><span class="pun">,</span><span class="pln"> lastPlacedNode</span><span class="pun">,</span><span class="pln"> nextIndex</span><span class="pun">,</span><span class="pln"> lastIndex</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
      lastIndex </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">max</span><span class="pun">(</span><span class="pln">prevChild</span><span class="pun">.</span><span class="pln">_mountIndex</span><span class="pun">,</span><span class="pln"> lastIndex</span><span class="pun">);</span><span class="pln">
      prevChild</span><span class="pun">.</span><span class="pln">_mountIndex </span><span class="pun">=</span><span class="pln"> nextIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">prevChild</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        lastIndex </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">max</span><span class="pun">(</span><span class="pln">prevChild</span><span class="pun">.</span><span class="pln">_mountIndex</span><span class="pun">,</span><span class="pln"> lastIndex</span><span class="pun">);</span><span class="pln">
        </span><span class="com">// 通过遍历 removedNodes 删除子节点 prevChild</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="com">// 初始化并创建节点</span><span class="pln">
      updates </span><span class="pun">=</span><span class="pln"> enqueue</span><span class="pun">(</span><span class="pln">
        updates</span><span class="pun">,</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_mountChildAtIndex</span><span class="pun">(</span><span class="pln">nextChild</span><span class="pun">,</span><span class="pln"> lastPlacedNode</span><span class="pun">,</span><span class="pln"> nextIndex</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    nextIndex</span><span class="pun">++;</span><span class="pln">
    lastPlacedNode </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">getNativeNode</span><span class="pun">(</span><span class="pln">nextChild</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果父节点不存在，则将其子节点全部移除</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">name </span><span class="kwd">in</span><span class="pln"> removedNodes</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">removedNodes</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">name</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      updates </span><span class="pun">=</span><span class="pln"> enqueue</span><span class="pun">(</span><span class="pln">
        updates</span><span class="pun">,</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_unmountChild</span><span class="pun">(</span><span class="pln">prevChildren</span><span class="pun">[</span><span class="pln">name</span><span class="pun">],</span><span class="pln"> removedNodes</span><span class="pun">[</span><span class="pln">name</span><span class="pun">])</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// 如果存在更新，则处理更新队列</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">updates</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    processQueue</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> updates</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_renderedChildren </span><span class="pun">=</span><span class="pln"> nextChildren</span><span class="pun">;</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> enqueue</span><span class="pun">(</span><span class="pln">queue</span><span class="pun">,</span><span class="pln"> update</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 如果有更新，将其存入 queue</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">update</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    queue </span><span class="pun">=</span><span class="pln"> queue </span><span class="pun">||</span><span class="pln"> </span><span class="pun">[];</span><span class="pln">
    queue</span><span class="pun">.</span><span class="pln">push</span><span class="pun">(</span><span class="pln">update</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> queue</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">// 处理队列的更新</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> processQueue</span><span class="pun">(</span><span class="pln">inst</span><span class="pun">,</span><span class="pln"> updateQueue</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="typ">ReactComponentEnvironment</span><span class="pun">.</span><span class="pln">processChildrenUpdates</span><span class="pun">(</span><span class="pln">
    inst</span><span class="pun">,</span><span class="pln">
    updateQueue</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">// 移动节点</span><span class="pln">
moveChild</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln"> toIndex</span><span class="pun">,</span><span class="pln"> lastIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 如果子节点的 index 小于 lastIndex，则移动该节点</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">child</span><span class="pun">.</span><span class="pln">_mountIndex </span><span class="pun">&lt;</span><span class="pln"> lastIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> makeMove</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln"> toIndex</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="com">// 创建节点</span><span class="pln">
createChild</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln"> mountImage</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> makeInsertMarkup</span><span class="pun">(</span><span class="pln">mountImage</span><span class="pun">,</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">_mountIndex</span><span class="pun">);</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="com">// 删除节点</span><span class="pln">
removeChild</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> node</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> makeRemove</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> node</span><span class="pun">);</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="com">// 卸载已经渲染的子节点</span><span class="pln">
_unmountChild</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> node</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> update </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">removeChild</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> node</span><span class="pun">);</span><span class="pln">
  child</span><span class="pun">.</span><span class="pln">_mountIndex </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> update</span><span class="pun">;</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="com">// 通过提供的名称实例化子节点</span><span class="pln">
_mountChildAtIndex</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln"> index</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> context</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> mountImage </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactReconciler</span><span class="pun">.</span><span class="pln">mountComponent</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> transaction</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_nativeContainerInfo</span><span class="pun">,</span><span class="pln">
    context</span><span class="pun">);</span><span class="pln">
  child</span><span class="pun">.</span><span class="pln">_mountIndex </span><span class="pun">=</span><span class="pln"> index</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">createChild</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> afterNode</span><span class="pun">,</span><span class="pln"> mountImage</span><span class="pun">);</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span></code></pre>
<p>当然，diff 还存在些许不足与待优化的地方。如图 3-24 所示，若新集合的节点更新为 D、A、B、C，与旧集合相比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在旧集合中的位置是最大的，导致其他节点的 <code>_mountIndex &lt; lastIndex</code>，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/05.d03z.024.png" alt="" width="85%" style="width: 85%"></p>
<p><strong>图 3-24　新集合的节点更新为D、A、B、C</strong></p>
<blockquote>
<p><strong>建议</strong>　在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。当节点数量过大或更新操作过于频繁时，这在一定程度上会影响 React 的渲染性能。</p>
</blockquote>
<h2><strong>3.6　React Patch 方法</strong></h2>
<p>通过前面的内容，我们了解了 React 如何构建虚拟标签，执行组件生命周期，更新 state，计算 tree diff 等，这一系列操作都还是在 Virtual DOM 中进行的。然而浏览器中并未能显示出更新的数据，那么 React 又是如何让浏览器展示出最新的数据呢？</p>
<p>React Patch 实现了关键的最后一步。所谓 Patch，简而言之就是将 tree diff 计算出来的 DOM 差异队列更新到真实的 DOM 节点上，最终让浏览器能够渲染出更新的数据。可以这么说，如果没有 Patch，那么 React 之前基于 Virtual DOM 做再多性能优化的操作都是徒劳，因为浏览器并不认识 Virtual DOM。虽然 Patch 方法如此重要，但它的实现却非常简洁明了，主要是通过遍历差异队列实现的。遍历差异队列时，通过更新类型进行相应的操作，包括：新节点的插入、已有节点的移动和移除等。</p>
<p>这里为什么可以直接依次插入节点呢？原因就是在 diff 阶段添加差异节点到差异队列时，本身就是有序添加。也就是说，新增节点（包括 <code>move</code> 和 <code>insert</code>）在队列里的顺序就是最终真实 DOM 的顺序，因此可以直接依次根据 <code>index</code> 去插入节点。而且，React 并不是计算出一个差异就去执行一次 Patch，而是计算出全部差异并放入差异队列后，再一次性地去执行 Patch 方法完成真实 DOM 的更新。</p>
<p>Patch方法的源码如下（源码路径：/v15.0.0/src/renderers/dom/client/utils/DOMChildrenOperations.js）：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">processUpdates</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> updates</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">//处理新增的节点、移动的节点以及需要移除的节点</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k </span><span class="pun">&lt;</span><span class="pln"> updates</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> update </span><span class="pun">=</span><span class="pln"> updates</span><span class="pun">[</span><span class="pln">k</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">update</span><span class="pun">.</span><span class="pln">type</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 插入新的节点</span><span class="pln">
      </span><span class="kwd">case</span><span class="pln"> </span><span class="typ">ReactMultiChildUpdateTypes</span><span class="pun">.</span><span class="pln">INSERT_MARKUP</span><span class="pun">:</span><span class="pln">
        insertLazyTreeChildAt</span><span class="pun">(</span><span class="pln">
          parentNode</span><span class="pun">,</span><span class="pln">
          update</span><span class="pun">.</span><span class="pln">content</span><span class="pun">,</span><span class="pln">
          getNodeAfter</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> update</span><span class="pun">.</span><span class="pln">afterNode</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
      </span><span class="com">// 需要移动的节点</span><span class="pln">
      </span><span class="kwd">case</span><span class="pln"> </span><span class="typ">ReactMultiChildUpdateTypes</span><span class="pun">.</span><span class="pln">MOVE_EXISTING</span><span class="pun">:</span><span class="pln">
        moveChild</span><span class="pun">(</span><span class="pln">
          parentNode</span><span class="pun">,</span><span class="pln">
          update</span><span class="pun">.</span><span class="pln">fromNode</span><span class="pun">,</span><span class="pln">
          getNodeAfter</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> update</span><span class="pun">.</span><span class="pln">afterNode</span><span class="pun">)</span><span class="pln">
        </span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">case</span><span class="pln"> </span><span class="typ">ReactMultiChildUpdateTypes</span><span class="pun">.</span><span class="pln">SET_MARKUP</span><span class="pun">:</span><span class="pln">
        setInnerHTML</span><span class="pun">(</span><span class="pln">
          parentNode</span><span class="pun">,</span><span class="pln">
          update</span><span class="pun">.</span><span class="pln">content
        </span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">case</span><span class="pln"> </span><span class="typ">ReactMultiChildUpdateTypes</span><span class="pun">.</span><span class="pln">TEXT_CONTENT</span><span class="pun">:</span><span class="pln">
        setTextContent</span><span class="pun">(</span><span class="pln">
          parentNode</span><span class="pun">,</span><span class="pln">
          update</span><span class="pun">.</span><span class="pln">content
        </span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
      </span><span class="com">// 需要删除的节点</span><span class="pln">
      </span><span class="kwd">case</span><span class="pln"> </span><span class="typ">ReactMultiChildUpdateTypes</span><span class="pun">.</span><span class="pln">REMOVE_NODE</span><span class="pun">:</span><span class="pln">
        removeChild</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> update</span><span class="pun">.</span><span class="pln">fromNode</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">},</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> getNodeAfter</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> node</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 文本组件的返回格式 [open, close] comments，需要做特殊处理</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Array</span><span class="pun">.</span><span class="pln">isArray</span><span class="pun">(</span><span class="pln">node</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    node </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">[</span><span class="lit">1</span><span class="pun">];</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> node </span><span class="pun">?</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">nextSibling </span><span class="pun">:</span><span class="pln"> parentNode</span><span class="pun">.</span><span class="pln">firstChild</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">// 插入新节点的操作</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> insertLazyTreeChildAt</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> childTree</span><span class="pun">,</span><span class="pln"> referenceNode</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="typ">DOMLazyTree</span><span class="pun">.</span><span class="pln">insertTreeBefore</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> childTree</span><span class="pun">,</span><span class="pln"> referenceNode</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">// 移动已有节点的操作</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> moveChild</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> childNode</span><span class="pun">,</span><span class="pln"> referenceNode</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Array</span><span class="pun">.</span><span class="pln">isArray</span><span class="pun">(</span><span class="pln">childNode</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    moveDelimitedText</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> childNode</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> childNode</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> referenceNode</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    insertChildAt</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> childNode</span><span class="pun">,</span><span class="pln"> referenceNode</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">// 移除已有节点的操作</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> removeChild</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> childNode</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Array</span><span class="pun">.</span><span class="pln">isArray</span><span class="pun">(</span><span class="pln">childNode</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> closingComment </span><span class="pun">=</span><span class="pln"> childNode</span><span class="pun">[</span><span class="lit">1</span><span class="pun">];</span><span class="pln">
    childNode </span><span class="pun">=</span><span class="pln"> childNode</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
    removeDelimitedText</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> childNode</span><span class="pun">,</span><span class="pln"> closingComment</span><span class="pun">);</span><span class="pln">
    parentNode</span><span class="pun">.</span><span class="pln">removeChild</span><span class="pun">(</span><span class="pln">closingComment</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  parentNode</span><span class="pun">.</span><span class="pln">removeChild</span><span class="pun">(</span><span class="pln">childNode</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">// 文本组件需要去除 openingComment 和 closingComment，取得其中的 node</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> moveDelimitedText</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> openingComment</span><span class="pun">,</span><span class="pln"> closingComment</span><span class="pun">,</span><span class="pln"> referenceNode</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> node </span><span class="pun">=</span><span class="pln"> openingComment</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">true</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> nextNode </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">nextSibling</span><span class="pun">;</span><span class="pln">
    insertChildAt</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> node</span><span class="pun">,</span><span class="pln"> referenceNode</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">node </span><span class="pun">===</span><span class="pln"> closingComment</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    node </span><span class="pun">=</span><span class="pln"> nextNode</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> removeDelimitedText</span><span class="pun">(</span><span class="pln">parentNode</span><span class="pun">,</span><span class="pln"> startNode</span><span class="pun">,</span><span class="pln"> closingComment</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">true</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> node </span><span class="pun">=</span><span class="pln"> startNode</span><span class="pun">.</span><span class="pln">nextSibling</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">node </span><span class="pun">===</span><span class="pln"> closingComment</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// closingComment 已经被 ReactMultiChild 移除</span><span class="pln">
      </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      parentNode</span><span class="pun">.</span><span class="pln">removeChild</span><span class="pun">(</span><span class="pln">node</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<h2><strong>3.7　小结</strong></h2>
<p>本章主要分析了 React 源码中 Virtual DOM 模型、组件生命周期的管理、<code>setState</code> 更新机制、diff 算法以及 Patch 方法。正因为 React 有着这样独特的设计，才让它站在了今天前端大舞台的聚光灯下。</p>
<p>除了本章分析的核心方法，React 还有许多优秀的实现，比如对象生成时内存的线程池管理、事件系统的优化、服务端的渲染等。在本章写作的过程中，React 15.0 版本又进行了几次小版本的更新，还发表了多年的研究成果 React Fiber，希望读者自行阅读源码分析其实现原理。</p>
